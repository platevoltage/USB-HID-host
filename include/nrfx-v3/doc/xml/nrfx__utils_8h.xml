<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.6" xml:lang="en-US">
  <compounddef id="nrfx__utils_8h" kind="file" language="C++">
    <compoundname>nrfx_utils.h</compoundname>
    <includes refid="nrfx__utils__internal_8h" local="yes">nrfx_utils_internal.h</includes>
    <includedby refid="nrfx__common_8h" local="yes">drivers/nrfx_common.h</includedby>
      <sectiondef kind="define">
      <memberdef kind="define" id="group__nrfx__utils_1ga3759226de0d998545425ded334168058" prot="public" static="no">
        <name>NRFX_COND_CODE_1</name>
        <param><defname>_flag</defname></param>
        <param><defname>_if_1_code</defname></param>
        <param><defname>_else_code</defname></param>
        <initializer>    _NRFX_COND_CODE_1(_flag, _if_1_code, _else_code)</initializer>
        <briefdescription>
<para>Macro for inserting code depending on whether <computeroutput>_flag</computeroutput> exists and expands to 1 or not. </para>
        </briefdescription>
        <detaileddescription>
<para>To prevent the preprocessor from treating commas as argument separators, the <computeroutput>_if_1_code</computeroutput> and <computeroutput>_else_code</computeroutput> expressions must be inside brackets/parentheses: <computeroutput>()</computeroutput>. These are stripped away during macro expansion.</para>
<para>Example: <verbatim>NRFX_COND_CODE_1(CONFIG_FLAG, (uint32_t x;), (there_is_no_flag();))
</verbatim> If <computeroutput>CONFIG_FLAG</computeroutput> is defined to 1, this expands to: <verbatim>uint32_t x;
</verbatim> It expands to <computeroutput>there_is_no_flag();</computeroutput> otherwise.</para>
<para>This could be used as an alternative to: <verbatim>#if defined(CONFIG_FLAG) &amp;&amp; (CONFIG_FLAG == 1)
#define MAYBE_DECLARE(x) uint32_t x
#else
#define MAYBE_DECLARE(x) there_is_no_flag()
#endif

MAYBE_DECLARE(x);
</verbatim> However, the advantage of COND_CODE_1() is that code is resolved in place where it is used, while the <computeroutput>#if</computeroutput> method defines <computeroutput>MAYBE_DECLARE</computeroutput> on two lines and requires it to be invoked again on a separate line. This makes COND_CODE_1() more concise and also sometimes more useful when used within another macro&apos;s expansion.</para>
<para><simplesect kind="note"><para><computeroutput>_flag</computeroutput> can be the result of preprocessor expansion, however <computeroutput>_if_1_code</computeroutput> is only expanded if <computeroutput>_flag</computeroutput> expands to the integer literal 1. Integer expressions that evaluate to 1, e.g. after doing some arithmetic, will not work.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">_flag</parametername>
</parameternamelist>
<parameterdescription>
<para>Evaluated flag </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_if_1_code</parametername>
</parameternamelist>
<parameterdescription>
<para>Result if <computeroutput>_flag</computeroutput> expands to 1; must be in parentheses </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_else_code</parametername>
</parameternamelist>
<parameterdescription>
<para>Result otherwise; must be in parentheses </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="89" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="89" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1gac0b7db186b16e71e28d7eb956869a30a" prot="public" static="no">
        <name>NRFX_COND_CODE_0</name>
        <param><defname>_flag</defname></param>
        <param><defname>_if_0_code</defname></param>
        <param><defname>_else_code</defname></param>
        <initializer>    _NRFX_COND_CODE_0(_flag, _if_0_code, _else_code)</initializer>
        <briefdescription>
<para>Macro for inserting code depending on whether <computeroutput>_flag</computeroutput> exists and expands to 0 or not. </para>
        </briefdescription>
        <detaileddescription>
<para>This is like <ref refid="group__nrfx__utils_1ga3759226de0d998545425ded334168058" kindref="member">NRFX_COND_CODE_1()</ref>, except that it tests whether <computeroutput>_flag</computeroutput> expands to the integer literal 0. It expands to <computeroutput>_if_0_code</computeroutput> if so, and <computeroutput>_else_code</computeroutput> otherwise; both of these must be enclosed in parentheses.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">_flag</parametername>
</parameternamelist>
<parameterdescription>
<para>Evaluated flag </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_if_0_code</parametername>
</parameternamelist>
<parameterdescription>
<para>Result if <computeroutput>_flag</computeroutput> expands to 0; must be in parentheses </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">_else_code</parametername>
</parameternamelist>
<parameterdescription>
<para>Result otherwise; must be in parentheses </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="104" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="104" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga238278032464c932dc46946bedd44473" prot="public" static="no">
        <name>NRFX_IS_ENABLED</name>
        <param><defname>config_macro</defname></param>
        <initializer>_NRFX_IS_ENABLED1(config_macro)</initializer>
        <briefdescription>
<para>Macro for checking for macro definition in compiler-visible expressions. </para>
        </briefdescription>
        <detaileddescription>
<para>It has the effect of taking a macro value that may be defined to &quot;1&quot; or may not be defined at all and turning it into a literal expression that can be handled by the C compiler instead of just the preprocessor.</para>
<para>That is, it works similarly to <computeroutput>#if defined(CONFIG_FOO)</computeroutput> except that its expansion is a C expression. Thus, much <computeroutput>#ifdef</computeroutput> usage can be replaced with equivalents like: <verbatim>if (IS_ENABLED(CONFIG_FOO)) {
        do_something_with_foo
}
</verbatim> This is cleaner since the compiler can generate errors and warnings for <computeroutput>do_something_with_foo</computeroutput> even when <computeroutput>CONFIG_FOO</computeroutput> is undefined.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">config_macro</parametername>
</parameternamelist>
<parameterdescription>
<para>Macro to check</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if <computeroutput>config_macro</computeroutput> is defined to 1, 0 otherwise (including if <computeroutput>config_macro</computeroutput> is not defined) </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="131" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="131" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1gaec8b3bf0959011b5e1eda4252a8f329a" prot="public" static="no">
        <name>NRFX_LISTIFY</name>
        <param><defname>LEN</defname></param>
        <param><defname>F</defname></param>
        <param><defname>sep</defname></param>
        <param><defname>...</defname></param>
        <initializer>    <ref refid="group__nrfx__common_1ga9fced903f4d0fc450e63d40426050236" kindref="member">NRFX_CONCAT_2</ref>(_NRFX_LISTIFY_, LEN)(F, sep, __VA_ARGS__)</initializer>
        <briefdescription>
<para>Macro for generating a sequence of code with configurable separator. </para>
        </briefdescription>
        <detaileddescription>
<para>Example: <verbatim>#define FOO(i, _) MY_PWM ## i
{ NRFX_LISTIFY(PWM_COUNT, FOO, (,)) }
</verbatim> The above two lines expand to:</para>
<para>{ MY_PWM0 , MY_PWM1 }</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">LEN</parametername>
</parameternamelist>
<parameterdescription>
<para>The length of the sequence. Must be an integer literal less than 255. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">F</parametername>
</parameternamelist>
<parameterdescription>
<para>A macro function that accepts at least two arguments: <computeroutput>F(i, ...)</computeroutput>. <computeroutput>F</computeroutput> is called repeatedly in the expansion. Its first argument <computeroutput>i</computeroutput> is the index in the sequence, and the variable list of arguments passed to LISTIFY are passed through to <computeroutput>F</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">sep</parametername>
</parameternamelist>
<parameterdescription>
<para>Separator (e.g. comma or semicolon). Must be in parentheses; this is required to enable providing a comma as separator.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>Calling NRFX_LISTIFY with undefined arguments has undefined behavior. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="157" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="157" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga49d7e75b5cdb92a5f8e4196c4f3e52bf" prot="public" static="no">
        <name>NRFX_IS_EMPTY</name>
        <param><defname>arg</defname></param>
        <initializer>_NRFX_IS_EMPTY(arg)</initializer>
        <briefdescription>
<para>Macro for checking if input argument is empty. </para>
        </briefdescription>
        <detaileddescription>
<para>Empty means that nothing is provided or provided value is resolved to nothing (e.g. empty define).</para>
<para>Macro idea is taken from P99 which is under Apache 2.0 license and described by Jens Gustedt <ulink url="https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments/">https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments/</ulink></para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Argument.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>if argument is empty. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>if argument is not empty. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="174" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="174" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga9b4880ee0671521522e81f00f8229fb5" prot="public" static="no">
        <name>NRFX_NUM_VA_ARGS_LESS_1</name>
        <param><defname>...</defname></param>
        <initializer>        _NRFX_NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__, 63, 62, 61, \
                    60, 59, 58, 57, 56, 55, 54, 53, 52, 51, \
                    50, 49, 48, 47, 46, 45, 44, 43, 42, 41, \
                    40, 39, 38, 37, 36, 35, 34, 33, 32, 31, \
                    30, 29, 28, 27, 26, 25, 24, 23, 22, 21, \
                    20, 19, 18, 17, 16, 15, 14, 13, 12, 11, \
                    10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ~)</initializer>
        <briefdescription>
<para>Macro for calculating number of arguments in the variable arguments list minus one. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para>List of arguments</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Number of variadic arguments in the argument list, minus one </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="183" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="183" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga5ea61d0994f6fb1ab5ed59d44f6a7ce9" prot="public" static="no">
        <name>NRFX_CONCAT</name>
        <param><defname>...</defname></param>
        <initializer>    <ref refid="group__nrfx__common_1ga9fced903f4d0fc450e63d40426050236" kindref="member">NRFX_CONCAT_2</ref>(_NRFX_CONCAT_, <ref refid="group__nrfx__utils_1ga9b4880ee0671521522e81f00f8229fb5" kindref="member">NRFX_NUM_VA_ARGS_LESS_1</ref>(__VA_ARGS__))(__VA_ARGS__)</initializer>
        <briefdescription>
<para>Macro for concatenating multiple arguments. </para>
        </briefdescription>
        <detaileddescription>
<para>Support up to 8 arguments.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">...</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments to concatenate. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="199" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="199" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga61259822a6d31a2d4cb15a9943a24521" prot="public" static="no">
        <name>NRFX_ARG_HAS_PARENTHESIS</name>
        <param><defname>x</defname></param>
        <initializer>_NRFX_GET_ARG3(_NRFX_EVAL(_NRFX_ARG_HAS_PARENTHESIS x, 1, 0))</initializer>
        <briefdescription>
<para>Macro for checking if argument starts with opening round bracket and contains matching closing bracket (parenthesis). </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">x</parametername>
</parameternamelist>
<parameterdescription>
<para>Input argument.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>1</parametername>
</parameternamelist>
<parameterdescription>
<para>If input argument starts with opening bracket and contains closing bracket. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>0</parametername>
</parameternamelist>
<parameterdescription>
<para>If input argument does not match above mentioned condition. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="211" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="211" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga9b551cefe9795f4eabe3a3cbce957ba6" prot="public" static="no">
        <name>NRFX_FOR_EACH</name>
        <param><defname>F</defname></param>
        <param><defname>sep</defname></param>
        <param><defname>...</defname></param>
        <initializer>    _NRFX_FOR_EACH(F, sep, <ref refid="group__nrfx__utils_1ga00142655b3872c09ccbe8178696b6d31" kindref="member">NRFX_REVERSE_ARGS</ref>(__VA_ARGS__))</initializer>
        <briefdescription>
<para>Macro for calling a macro <computeroutput>F</computeroutput> on each provided argument with a given separator between each call. </para>
        </briefdescription>
        <detaileddescription>
<para>Example: <verbatim>#define F(x) int a##x
NRFX_FOR_EACH(F, (;), 4, 5, 6);
</verbatim> This expands to: <verbatim>int a4;
int a5;
int a6;
</verbatim> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>Macro to invoke </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sep</parametername>
</parameternamelist>
<parameterdescription>
<para>Separator (e.g. comma or semicolon). Must be in parentheses; this is required to enable providing a comma as a separator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable argument list. The macro <computeroutput>F</computeroutput> is invoked as <computeroutput>F(element)</computeroutput> for each element in the list. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="234" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="234" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga17d2cf34acf3b05105b494aab2e14926" prot="public" static="no">
        <name>NRFX_FOR_EACH_IDX</name>
        <param><defname>F</defname></param>
        <param><defname>sep</defname></param>
        <param><defname>...</defname></param>
        <initializer>    _NRFX_FOR_EACH_IDX(F, sep, <ref refid="group__nrfx__utils_1ga00142655b3872c09ccbe8178696b6d31" kindref="member">NRFX_REVERSE_ARGS</ref>(__VA_ARGS__))</initializer>
        <briefdescription>
<para>Call macro <computeroutput>F</computeroutput> on each provided argument, with the argument&apos;s index as an additional parameter. </para>
        </briefdescription>
        <detaileddescription>
<para>This is like <ref refid="group__nrfx__utils_1ga9b551cefe9795f4eabe3a3cbce957ba6" kindref="member">NRFX_FOR_EACH()</ref>, except <computeroutput>F</computeroutput> should be a macro which takes two arguments: <computeroutput>F(index, variable_arg)</computeroutput>.</para>
<para>Example: <verbatim>#define F(idx, x) int a##idx = x
NRFX_FOR_EACH_IDX(F, (;), 4, 5, 6);
</verbatim> This expands to: <verbatim>int a0 = 4;
int a1 = 5;
int a2 = 6;
</verbatim> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>Macro to invoke </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sep</parametername>
</parameternamelist>
<parameterdescription>
<para>Separator (e.g. comma or semicolon). Must be in parentheses; this is required to enable providing a comma as a separator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable argument list. The macro <computeroutput>F</computeroutput> is invoked as <computeroutput>F(index, element)</computeroutput> for each element in the list. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="261" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="261" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1gaf9a75fa66390a5833db6697214dba323" prot="public" static="no">
        <name>NRFX_FOR_EACH_FIXED_ARG</name>
        <param><defname>F</defname></param>
        <param><defname>sep</defname></param>
        <param><defname>fixed_arg</defname></param>
        <param><defname>...</defname></param>
        <initializer>    _NRFX_FOR_EACH_FIXED_ARG(F, sep, fixed_arg, <ref refid="group__nrfx__utils_1ga00142655b3872c09ccbe8178696b6d31" kindref="member">NRFX_REVERSE_ARGS</ref>(__VA_ARGS__))</initializer>
        <briefdescription>
<para>Macro for calling macro <computeroutput>F</computeroutput> on each provided argument, with an additional fixed argument as a parameter. </para>
        </briefdescription>
        <detaileddescription>
<para>This is like <ref refid="group__nrfx__utils_1ga9b551cefe9795f4eabe3a3cbce957ba6" kindref="member">NRFX_FOR_EACH()</ref>, except <computeroutput>F</computeroutput> should be a macro which takes two arguments: <computeroutput>F(variable_arg, fixed_arg)</computeroutput>.</para>
<para>Example: <verbatim>static void func(int val, void *dev);
NRFX_FOR_EACH_FIXED_ARG(func, (;), dev, 4, 5, 6);
</verbatim> This expands to: <verbatim>func(4, dev);
func(5, dev);
func(6, dev);
</verbatim> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>Macro to invoke </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sep</parametername>
</parameternamelist>
<parameterdescription>
<para>Separator (e.g. comma or semicolon). Must be in parentheses; this is required to enable providing a comma as a separator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fixed_arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Fixed argument passed to <computeroutput>F</computeroutput> as the second macro parameter. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable argument list. The macro <computeroutput>F</computeroutput> is invoked as <computeroutput>F(element, fixed_arg)</computeroutput> for each element in the list. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="289" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="289" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga70aaf745a268eaf9afb98f00f542231e" prot="public" static="no">
        <name>NRFX_FOR_EACH_IDX_FIXED_ARG</name>
        <param><defname>F</defname></param>
        <param><defname>sep</defname></param>
        <param><defname>fixed_arg</defname></param>
        <param><defname>...</defname></param>
        <initializer>    _NRFX_FOR_EACH_IDX_FIXED_ARG(F, sep, fixed_arg, <ref refid="group__nrfx__utils_1ga00142655b3872c09ccbe8178696b6d31" kindref="member">NRFX_REVERSE_ARGS</ref>(__VA_ARGS__))</initializer>
        <briefdescription>
<para>Macro from calling macro <computeroutput>F</computeroutput> for each variable argument with an index and fixed argument. </para>
        </briefdescription>
        <detaileddescription>
<para>This is like the combination of <ref refid="group__nrfx__utils_1ga17d2cf34acf3b05105b494aab2e14926" kindref="member">NRFX_FOR_EACH_IDX()</ref> with <ref refid="group__nrfx__utils_1gaf9a75fa66390a5833db6697214dba323" kindref="member">NRFX_FOR_EACH_FIXED_ARG()</ref>.</para>
<para>Example: <verbatim>#define F(idx, x, fixed_arg) int fixed_arg##idx = x
NRFX_FOR_EACH_IDX_FIXED_ARG(F, (;), a, 4, 5, 6);
</verbatim> This expands to: <verbatim>int a0 = 4;
int a1 = 5;
int a2 = 6;
</verbatim> <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>Macro to invoke </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sep</parametername>
</parameternamelist>
<parameterdescription>
<para>Separator (e.g. comma or semicolon). Must be in parentheses; This is required to enable providing a comma as a separator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fixed_arg</parametername>
</parameternamelist>
<parameterdescription>
<para>Fixed argument passed to <computeroutput>F</computeroutput> as the third macro parameter. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable list of arguments. The macro <computeroutput>F</computeroutput> is invoked as <computeroutput>F(index, element, fixed_arg)</computeroutput> for each element in the list. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="317" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="317" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga00142655b3872c09ccbe8178696b6d31" prot="public" static="no">
        <name>NRFX_REVERSE_ARGS</name>
        <param><defname>...</defname></param>
        <initializer>    _NRFX_FOR_EACH_ENGINE(_NRFX_FOR_EACH_EXEC, (,), NRFX_EVAL, _, __VA_ARGS__)</initializer>
        <briefdescription>
<para>Macro for reversing arguments order. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable argument list.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Input arguments in reversed order. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="327" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="327" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__nrfx__utils_1ga7558c8c1390a9256f39a82da2087c8df" prot="public" static="no">
        <name>NRFX_MAX_N</name>
        <param><defname>...</defname></param>
        <initializer>    NRFX_EVAL(<ref refid="group__nrfx__utils_1ga9b551cefe9795f4eabe3a3cbce957ba6" kindref="member">NRFX_FOR_EACH</ref>(_NRFX_MAX_P1, (), __VA_ARGS__) 0 \
              <ref refid="group__nrfx__utils_1ga9b551cefe9795f4eabe3a3cbce957ba6" kindref="member">NRFX_FOR_EACH</ref>(_NRFX_MAX_P2, (), __VA_ARGS__))</initializer>
        <briefdescription>
<para>Macro for getting the highest value from input arguments. </para>
        </briefdescription>
        <detaileddescription>
<para>It is similar to <ref refid="group__nrfx__common_1gaaf20fb75ada3be75dbf03d6fe4d43f6a" kindref="member">NRFX_MAX</ref> but accepts a variable number of arguments.</para>
<para><simplesect kind="note"><para>Input arguments must be numeric variables.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>...</parametername>
</parameternamelist>
<parameterdescription>
<para>Variable argument list.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Highest value from the input list. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="drivers/nrfx_utils.h" line="342" column="9" bodyfile="drivers/nrfx_utils.h" bodystart="342" bodyend="-1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="2"><highlight class="comment"><sp/>*<sp/>Copyright<sp/>(c)<sp/>2022<sp/>-<sp/>2024,<sp/>Nordic<sp/>Semiconductor<sp/>ASA</highlight></codeline>
<codeline lineno="3"><highlight class="comment"><sp/>*<sp/>All<sp/>rights<sp/>reserved.</highlight></codeline>
<codeline lineno="4"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="5"><highlight class="comment"><sp/>*<sp/>SPDX-License-Identifier:<sp/>BSD-3-Clause</highlight></codeline>
<codeline lineno="6"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="7"><highlight class="comment"><sp/>*<sp/>Redistribution<sp/>and<sp/>use<sp/>in<sp/>source<sp/>and<sp/>binary<sp/>forms,<sp/>with<sp/>or<sp/>without</highlight></codeline>
<codeline lineno="8"><highlight class="comment"><sp/>*<sp/>modification,<sp/>are<sp/>permitted<sp/>provided<sp/>that<sp/>the<sp/>following<sp/>conditions<sp/>are<sp/>met:</highlight></codeline>
<codeline lineno="9"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="10"><highlight class="comment"><sp/>*<sp/>1.<sp/>Redistributions<sp/>of<sp/>source<sp/>code<sp/>must<sp/>retain<sp/>the<sp/>above<sp/>copyright<sp/>notice,<sp/>this</highlight></codeline>
<codeline lineno="11"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer.</highlight></codeline>
<codeline lineno="12"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="13"><highlight class="comment"><sp/>*<sp/>2.<sp/>Redistributions<sp/>in<sp/>binary<sp/>form<sp/>must<sp/>reproduce<sp/>the<sp/>above<sp/>copyright</highlight></codeline>
<codeline lineno="14"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>notice,<sp/>this<sp/>list<sp/>of<sp/>conditions<sp/>and<sp/>the<sp/>following<sp/>disclaimer<sp/>in<sp/>the</highlight></codeline>
<codeline lineno="15"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>documentation<sp/>and/or<sp/>other<sp/>materials<sp/>provided<sp/>with<sp/>the<sp/>distribution.</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*<sp/>3.<sp/>Neither<sp/>the<sp/>name<sp/>of<sp/>the<sp/>copyright<sp/>holder<sp/>nor<sp/>the<sp/>names<sp/>of<sp/>its</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>contributors<sp/>may<sp/>be<sp/>used<sp/>to<sp/>endorse<sp/>or<sp/>promote<sp/>products<sp/>derived<sp/>from<sp/>this</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>software<sp/>without<sp/>specific<sp/>prior<sp/>written<sp/>permission.</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*<sp/>THIS<sp/>SOFTWARE<sp/>IS<sp/>PROVIDED<sp/>BY<sp/>THE<sp/>COPYRIGHT<sp/>HOLDERS<sp/>AND<sp/>CONTRIBUTORS<sp/>&quot;AS<sp/>IS&quot;</highlight></codeline>
<codeline lineno="22"><highlight class="comment"><sp/>*<sp/>AND<sp/>ANY<sp/>EXPRESS<sp/>OR<sp/>IMPLIED<sp/>WARRANTIES,<sp/>INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,<sp/>THE</highlight></codeline>
<codeline lineno="23"><highlight class="comment"><sp/>*<sp/>IMPLIED<sp/>WARRANTIES<sp/>OF<sp/>MERCHANTABILITY<sp/>AND<sp/>FITNESS<sp/>FOR<sp/>A<sp/>PARTICULAR<sp/>PURPOSE</highlight></codeline>
<codeline lineno="24"><highlight class="comment"><sp/>*<sp/>ARE<sp/>DISCLAIMED.<sp/>IN<sp/>NO<sp/>EVENT<sp/>SHALL<sp/>THE<sp/>COPYRIGHT<sp/>HOLDER<sp/>OR<sp/>CONTRIBUTORS<sp/>BE</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/>*<sp/>LIABLE<sp/>FOR<sp/>ANY<sp/>DIRECT,<sp/>INDIRECT,<sp/>INCIDENTAL,<sp/>SPECIAL,<sp/>EXEMPLARY,<sp/>OR</highlight></codeline>
<codeline lineno="26"><highlight class="comment"><sp/>*<sp/>CONSEQUENTIAL<sp/>DAMAGES<sp/>(INCLUDING,<sp/>BUT<sp/>NOT<sp/>LIMITED<sp/>TO,<sp/>PROCUREMENT<sp/>OF</highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/>*<sp/>SUBSTITUTE<sp/>GOODS<sp/>OR<sp/>SERVICES;<sp/>LOSS<sp/>OF<sp/>USE,<sp/>DATA,<sp/>OR<sp/>PROFITS;<sp/>OR<sp/>BUSINESS</highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/>*<sp/>INTERRUPTION)<sp/>HOWEVER<sp/>CAUSED<sp/>AND<sp/>ON<sp/>ANY<sp/>THEORY<sp/>OF<sp/>LIABILITY,<sp/>WHETHER<sp/>IN</highlight></codeline>
<codeline lineno="29"><highlight class="comment"><sp/>*<sp/>CONTRACT,<sp/>STRICT<sp/>LIABILITY,<sp/>OR<sp/>TORT<sp/>(INCLUDING<sp/>NEGLIGENCE<sp/>OR<sp/>OTHERWISE)</highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*<sp/>ARISING<sp/>IN<sp/>ANY<sp/>WAY<sp/>OUT<sp/>OF<sp/>THE<sp/>USE<sp/>OF<sp/>THIS<sp/>SOFTWARE,<sp/>EVEN<sp/>IF<sp/>ADVISED<sp/>OF<sp/>THE</highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/>*<sp/>POSSIBILITY<sp/>OF<sp/>SUCH<sp/>DAMAGE.</highlight></codeline>
<codeline lineno="32"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>NRFX_UTILS_H__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_UTILS_H__</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;nrfx_utils_internal.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="39"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="40"><highlight class="comment"><sp/>*<sp/>@defgroup<sp/>nrfx_utils<sp/>Preprocessor<sp/>utility<sp/>macros</highlight></codeline>
<codeline lineno="41"><highlight class="comment"><sp/>*<sp/>@{</highlight></codeline>
<codeline lineno="42"><highlight class="comment"><sp/>*<sp/>@ingroup<sp/>nrfx</highlight></codeline>
<codeline lineno="43"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Preprocessor<sp/>utility<sp/>macros.</highlight></codeline>
<codeline lineno="44"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="46"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="47"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>inserting<sp/>code<sp/>depending<sp/>on<sp/>whether<sp/>@p<sp/>_flag<sp/>exists<sp/>and<sp/>expands<sp/>to<sp/>1<sp/>or<sp/>not.</highlight></codeline>
<codeline lineno="48"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="49"><highlight class="comment"><sp/>*<sp/>To<sp/>prevent<sp/>the<sp/>preprocessor<sp/>from<sp/>treating<sp/>commas<sp/>as<sp/>argument</highlight></codeline>
<codeline lineno="50"><highlight class="comment"><sp/>*<sp/>separators,<sp/>the<sp/>@p<sp/>_if_1_code<sp/>and<sp/>@p<sp/>_else_code<sp/>expressions<sp/>must<sp/>be</highlight></codeline>
<codeline lineno="51"><highlight class="comment"><sp/>*<sp/>inside<sp/>brackets/parentheses:<sp/>&lt;tt&gt;()&lt;/tt&gt;.<sp/>These<sp/>are<sp/>stripped<sp/>away</highlight></codeline>
<codeline lineno="52"><highlight class="comment"><sp/>*<sp/>during<sp/>macro<sp/>expansion.</highlight></codeline>
<codeline lineno="53"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="54"><highlight class="comment"><sp/>*<sp/>Example:</highlight></codeline>
<codeline lineno="55"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="56"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>NRFX_COND_CODE_1(CONFIG_FLAG,<sp/>(uint32_t<sp/>x;),<sp/>(there_is_no_flag();))</highlight></codeline>
<codeline lineno="57"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="58"><highlight class="comment"><sp/>*<sp/>If<sp/>@p<sp/>CONFIG_FLAG<sp/>is<sp/>defined<sp/>to<sp/>1,<sp/>this<sp/>expands<sp/>to:</highlight></codeline>
<codeline lineno="59"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="60"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>uint32_t<sp/>x;</highlight></codeline>
<codeline lineno="61"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="62"><highlight class="comment"><sp/>*<sp/>It<sp/>expands<sp/>to<sp/>&lt;tt&gt;there_is_no_flag();&lt;/tt&gt;<sp/>otherwise.</highlight></codeline>
<codeline lineno="63"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="64"><highlight class="comment"><sp/>*<sp/>This<sp/>could<sp/>be<sp/>used<sp/>as<sp/>an<sp/>alternative<sp/>to:</highlight></codeline>
<codeline lineno="65"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="66"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#if<sp/>defined(CONFIG_FLAG)<sp/>&amp;&amp;<sp/>(CONFIG_FLAG<sp/>==<sp/>1)</highlight></codeline>
<codeline lineno="67"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#define<sp/>MAYBE_DECLARE(x)<sp/>uint32_t<sp/>x</highlight></codeline>
<codeline lineno="68"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline lineno="69"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#define<sp/>MAYBE_DECLARE(x)<sp/>there_is_no_flag()</highlight></codeline>
<codeline lineno="70"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline lineno="71"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="72"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>MAYBE_DECLARE(x);</highlight></codeline>
<codeline lineno="73"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="74"><highlight class="comment"><sp/>*<sp/>However,<sp/>the<sp/>advantage<sp/>of<sp/>COND_CODE_1()<sp/>is<sp/>that<sp/>code<sp/>is<sp/>resolved<sp/>in</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/>*<sp/>place<sp/>where<sp/>it<sp/>is<sp/>used,<sp/>while<sp/>the<sp/>@p<sp/>\#if<sp/>method<sp/>defines<sp/>@p</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/>*<sp/>MAYBE_DECLARE<sp/>on<sp/>two<sp/>lines<sp/>and<sp/>requires<sp/>it<sp/>to<sp/>be<sp/>invoked<sp/>again<sp/>on<sp/>a</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/>*<sp/>separate<sp/>line.<sp/>This<sp/>makes<sp/>COND_CODE_1()<sp/>more<sp/>concise<sp/>and<sp/>also</highlight></codeline>
<codeline lineno="78"><highlight class="comment"><sp/>*<sp/>sometimes<sp/>more<sp/>useful<sp/>when<sp/>used<sp/>within<sp/>another<sp/>macro&apos;s<sp/>expansion.</highlight></codeline>
<codeline lineno="79"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="80"><highlight class="comment"><sp/>*<sp/>@note<sp/>@p<sp/>_flag<sp/>can<sp/>be<sp/>the<sp/>result<sp/>of<sp/>preprocessor<sp/>expansion,</highlight></codeline>
<codeline lineno="81"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/>however<sp/>@p<sp/>_if_1_code<sp/>is<sp/>only<sp/>expanded<sp/>if<sp/>@p<sp/>_flag<sp/>expands</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/>to<sp/>the<sp/>integer<sp/>literal<sp/>1.<sp/>Integer<sp/>expressions<sp/>that<sp/>evaluate</highlight></codeline>
<codeline lineno="83"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/>to<sp/>1,<sp/>e.g.<sp/>after<sp/>doing<sp/>some<sp/>arithmetic,<sp/>will<sp/>not<sp/>work.</highlight></codeline>
<codeline lineno="84"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="85"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>_flag<sp/><sp/><sp/><sp/><sp/><sp/>Evaluated<sp/>flag</highlight></codeline>
<codeline lineno="86"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>_if_1_code<sp/>Result<sp/>if<sp/>@p<sp/>_flag<sp/>expands<sp/>to<sp/>1;<sp/>must<sp/>be<sp/>in<sp/>parentheses</highlight></codeline>
<codeline lineno="87"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>_else_code<sp/>Result<sp/>otherwise;<sp/>must<sp/>be<sp/>in<sp/>parentheses</highlight></codeline>
<codeline lineno="88"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_COND_CODE_1(_flag,<sp/>_if_1_code,<sp/>_else_code)<sp/>\</highlight></codeline>
<codeline lineno="90"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>_NRFX_COND_CODE_1(_flag,<sp/>_if_1_code,<sp/>_else_code)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="92"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="93"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>inserting<sp/>code<sp/>depending<sp/>on<sp/>whether<sp/>@p<sp/>_flag<sp/>exists<sp/>and<sp/>expands<sp/>to<sp/>0<sp/>or<sp/>not.</highlight></codeline>
<codeline lineno="94"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="95"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>like<sp/>@ref<sp/>NRFX_COND_CODE_1(),<sp/>except<sp/>that<sp/>it<sp/>tests<sp/>whether<sp/>@p<sp/>_flag</highlight></codeline>
<codeline lineno="96"><highlight class="comment"><sp/>*<sp/>expands<sp/>to<sp/>the<sp/>integer<sp/>literal<sp/>0.<sp/>It<sp/>expands<sp/>to<sp/>@p<sp/>_if_0_code<sp/>if</highlight></codeline>
<codeline lineno="97"><highlight class="comment"><sp/>*<sp/>so,<sp/>and<sp/>@p<sp/>_else_code<sp/>otherwise;<sp/>both<sp/>of<sp/>these<sp/>must<sp/>be<sp/>enclosed<sp/>in</highlight></codeline>
<codeline lineno="98"><highlight class="comment"><sp/>*<sp/>parentheses.</highlight></codeline>
<codeline lineno="99"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="100"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>_flag<sp/><sp/><sp/><sp/><sp/><sp/>Evaluated<sp/>flag</highlight></codeline>
<codeline lineno="101"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>_if_0_code<sp/>Result<sp/>if<sp/>@p<sp/>_flag<sp/>expands<sp/>to<sp/>0;<sp/>must<sp/>be<sp/>in<sp/>parentheses</highlight></codeline>
<codeline lineno="102"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>_else_code<sp/>Result<sp/>otherwise;<sp/>must<sp/>be<sp/>in<sp/>parentheses</highlight></codeline>
<codeline lineno="103"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_COND_CODE_0(_flag,<sp/>_if_0_code,<sp/>_else_code)<sp/>\</highlight></codeline>
<codeline lineno="105"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>_NRFX_COND_CODE_0(_flag,<sp/>_if_0_code,<sp/>_else_code)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="107"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="108"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>checking<sp/>for<sp/>macro<sp/>definition<sp/>in<sp/>compiler-visible<sp/>expressions</highlight></codeline>
<codeline lineno="109"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="110"><highlight class="comment"><sp/>*<sp/>It<sp/>has<sp/>the<sp/>effect<sp/>of<sp/>taking<sp/>a<sp/>macro<sp/>value<sp/>that<sp/>may<sp/>be<sp/>defined<sp/>to<sp/>&quot;1&quot;</highlight></codeline>
<codeline lineno="111"><highlight class="comment"><sp/>*<sp/>or<sp/>may<sp/>not<sp/>be<sp/>defined<sp/>at<sp/>all<sp/>and<sp/>turning<sp/>it<sp/>into<sp/>a<sp/>literal</highlight></codeline>
<codeline lineno="112"><highlight class="comment"><sp/>*<sp/>expression<sp/>that<sp/>can<sp/>be<sp/>handled<sp/>by<sp/>the<sp/>C<sp/>compiler<sp/>instead<sp/>of<sp/>just</highlight></codeline>
<codeline lineno="113"><highlight class="comment"><sp/>*<sp/>the<sp/>preprocessor.</highlight></codeline>
<codeline lineno="114"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="115"><highlight class="comment"><sp/>*<sp/>That<sp/>is,<sp/>it<sp/>works<sp/>similarly<sp/>to<sp/>&lt;tt&gt;\#if<sp/>defined(CONFIG_FOO)&lt;/tt&gt;</highlight></codeline>
<codeline lineno="116"><highlight class="comment"><sp/>*<sp/>except<sp/>that<sp/>its<sp/>expansion<sp/>is<sp/>a<sp/>C<sp/>expression.<sp/>Thus,<sp/>much<sp/>&lt;tt&gt;\#ifdef&lt;/tt&gt;</highlight></codeline>
<codeline lineno="117"><highlight class="comment"><sp/>*<sp/>usage<sp/>can<sp/>be<sp/>replaced<sp/>with<sp/>equivalents<sp/>like:</highlight></codeline>
<codeline lineno="118"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="119"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>if<sp/>(IS_ENABLED(CONFIG_FOO))<sp/>{</highlight></codeline>
<codeline lineno="120"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>do_something_with_foo</highlight></codeline>
<codeline lineno="121"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="122"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="123"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>cleaner<sp/>since<sp/>the<sp/>compiler<sp/>can<sp/>generate<sp/>errors<sp/>and<sp/>warnings</highlight></codeline>
<codeline lineno="124"><highlight class="comment"><sp/>*<sp/>for<sp/>@p<sp/>do_something_with_foo<sp/>even<sp/>when<sp/>@p<sp/>CONFIG_FOO<sp/>is<sp/>undefined.</highlight></codeline>
<codeline lineno="125"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="126"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>config_macro<sp/>Macro<sp/>to<sp/>check</highlight></codeline>
<codeline lineno="127"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="128"><highlight class="comment"><sp/>*<sp/>@return<sp/>1<sp/>if<sp/>@p<sp/>config_macro<sp/>is<sp/>defined<sp/>to<sp/>1,<sp/>0<sp/>otherwise<sp/>(including</highlight></codeline>
<codeline lineno="129"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>@p<sp/>config_macro<sp/>is<sp/>not<sp/>defined)</highlight></codeline>
<codeline lineno="130"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_IS_ENABLED(config_macro)<sp/>_NRFX_IS_ENABLED1(config_macro)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="133"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="134"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>generating<sp/>a<sp/>sequence<sp/>of<sp/>code<sp/>with<sp/>configurable<sp/>separator.</highlight></codeline>
<codeline lineno="135"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="136"><highlight class="comment"><sp/>*<sp/>Example:</highlight></codeline>
<codeline lineno="137"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="138"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#define<sp/>FOO(i,<sp/>_)<sp/>MY_PWM<sp/>##<sp/>i</highlight></codeline>
<codeline lineno="139"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>{<sp/>NRFX_LISTIFY(PWM_COUNT,<sp/>FOO,<sp/>(,))<sp/>}</highlight></codeline>
<codeline lineno="140"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="141"><highlight class="comment"><sp/>*<sp/>The<sp/>above<sp/>two<sp/>lines<sp/>expand<sp/>to:</highlight></codeline>
<codeline lineno="142"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/>{<sp/>MY_PWM0<sp/>,<sp/>MY_PWM1<sp/>}</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="145"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>LEN<sp/>The<sp/>length<sp/>of<sp/>the<sp/>sequence.<sp/>Must<sp/>be<sp/>an<sp/>integer<sp/>literal<sp/>less</highlight></codeline>
<codeline lineno="146"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>than<sp/>255.</highlight></codeline>
<codeline lineno="147"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>F<sp/><sp/><sp/>A<sp/>macro<sp/>function<sp/>that<sp/>accepts<sp/>at<sp/>least<sp/>two<sp/>arguments:</highlight></codeline>
<codeline lineno="148"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;tt&gt;F(i,<sp/>...)&lt;/tt&gt;.<sp/>@p<sp/>F<sp/>is<sp/>called<sp/>repeatedly<sp/>in<sp/>the<sp/>expansion.</highlight></codeline>
<codeline lineno="149"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Its<sp/>first<sp/>argument<sp/>@p<sp/>i<sp/>is<sp/>the<sp/>index<sp/>in<sp/>the<sp/>sequence,<sp/>and</highlight></codeline>
<codeline lineno="150"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>the<sp/>variable<sp/>list<sp/>of<sp/>arguments<sp/>passed<sp/>to<sp/>LISTIFY<sp/>are<sp/>passed</highlight></codeline>
<codeline lineno="151"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>through<sp/>to<sp/>@p<sp/>F.</highlight></codeline>
<codeline lineno="152"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>sep<sp/>Separator<sp/>(e.g.<sp/>comma<sp/>or<sp/>semicolon).<sp/>Must<sp/>be<sp/>in<sp/>parentheses;</highlight></codeline>
<codeline lineno="153"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this<sp/>is<sp/>required<sp/>to<sp/>enable<sp/>providing<sp/>a<sp/>comma<sp/>as<sp/>separator.</highlight></codeline>
<codeline lineno="154"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="155"><highlight class="comment"><sp/>*<sp/>@note<sp/>Calling<sp/>NRFX_LISTIFY<sp/>with<sp/>undefined<sp/>arguments<sp/>has<sp/>undefined<sp/>behavior.</highlight></codeline>
<codeline lineno="156"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_LISTIFY(LEN,<sp/>F,<sp/>sep,<sp/>...)<sp/>\</highlight></codeline>
<codeline lineno="158"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>NRFX_CONCAT_2(_NRFX_LISTIFY_,<sp/>LEN)(F,<sp/>sep,<sp/>__VA_ARGS__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="159"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="160"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="161"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>checking<sp/>if<sp/>input<sp/>argument<sp/>is<sp/>empty.</highlight></codeline>
<codeline lineno="162"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="163"><highlight class="comment"><sp/>*<sp/>Empty<sp/>means<sp/>that<sp/>nothing<sp/>is<sp/>provided<sp/>or<sp/>provided<sp/>value<sp/>is<sp/>resolved<sp/>to<sp/>nothing</highlight></codeline>
<codeline lineno="164"><highlight class="comment"><sp/>*<sp/>(e.g.<sp/>empty<sp/>define).</highlight></codeline>
<codeline lineno="165"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="166"><highlight class="comment"><sp/>*<sp/>Macro<sp/>idea<sp/>is<sp/>taken<sp/>from<sp/>P99<sp/>which<sp/>is<sp/>under<sp/>Apache<sp/>2.0<sp/>license<sp/>and<sp/>described<sp/>by</highlight></codeline>
<codeline lineno="167"><highlight class="comment"><sp/>*<sp/>Jens<sp/>Gustedt<sp/>https://gustedt.wordpress.com/2010/06/08/detect-empty-macro-arguments/</highlight></codeline>
<codeline lineno="168"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="169"><highlight class="comment"><sp/>*<sp/>@param<sp/>arg<sp/>Argument.</highlight></codeline>
<codeline lineno="170"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="171"><highlight class="comment"><sp/>*<sp/>@retval<sp/>1<sp/>if<sp/>argument<sp/>is<sp/>empty.</highlight></codeline>
<codeline lineno="172"><highlight class="comment"><sp/>*<sp/>@retval<sp/>0<sp/>if<sp/>argument<sp/>is<sp/>not<sp/>empty.</highlight></codeline>
<codeline lineno="173"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_IS_EMPTY(arg)<sp/>_NRFX_IS_EMPTY(arg)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="176"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="177"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>calculating<sp/>number<sp/>of<sp/>arguments<sp/>in<sp/>the<sp/>variable<sp/>arguments<sp/>list<sp/>minus<sp/>one.</highlight></codeline>
<codeline lineno="178"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="179"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>...<sp/>List<sp/>of<sp/>arguments</highlight></codeline>
<codeline lineno="180"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="181"><highlight class="comment"><sp/>*<sp/>@return<sp/>Number<sp/>of<sp/>variadic<sp/>arguments<sp/>in<sp/>the<sp/>argument<sp/>list,<sp/>minus<sp/>one</highlight></codeline>
<codeline lineno="182"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_NUM_VA_ARGS_LESS_1(...)<sp/>\</highlight></codeline>
<codeline lineno="184"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_NRFX_NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__,<sp/>63,<sp/>62,<sp/>61,<sp/>\</highlight></codeline>
<codeline lineno="185"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>60,<sp/>59,<sp/>58,<sp/>57,<sp/>56,<sp/>55,<sp/>54,<sp/>53,<sp/>52,<sp/>51,<sp/>\</highlight></codeline>
<codeline lineno="186"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>50,<sp/>49,<sp/>48,<sp/>47,<sp/>46,<sp/>45,<sp/>44,<sp/>43,<sp/>42,<sp/>41,<sp/>\</highlight></codeline>
<codeline lineno="187"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>40,<sp/>39,<sp/>38,<sp/>37,<sp/>36,<sp/>35,<sp/>34,<sp/>33,<sp/>32,<sp/>31,<sp/>\</highlight></codeline>
<codeline lineno="188"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>30,<sp/>29,<sp/>28,<sp/>27,<sp/>26,<sp/>25,<sp/>24,<sp/>23,<sp/>22,<sp/>21,<sp/>\</highlight></codeline>
<codeline lineno="189"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>20,<sp/>19,<sp/>18,<sp/>17,<sp/>16,<sp/>15,<sp/>14,<sp/>13,<sp/>12,<sp/>11,<sp/>\</highlight></codeline>
<codeline lineno="190"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>10,<sp/>9,<sp/>8,<sp/>7,<sp/>6,<sp/>5,<sp/>4,<sp/>3,<sp/>2,<sp/>1,<sp/>0,<sp/>~)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="192"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="193"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>concatenating<sp/>multiple<sp/>arguments.</highlight></codeline>
<codeline lineno="194"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="195"><highlight class="comment"><sp/>*<sp/>Support<sp/>up<sp/>to<sp/>8<sp/>arguments.</highlight></codeline>
<codeline lineno="196"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="197"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>...<sp/>Arguments<sp/>to<sp/>concatenate.</highlight></codeline>
<codeline lineno="198"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_CONCAT(...)<sp/>\</highlight></codeline>
<codeline lineno="200"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>NRFX_CONCAT_2(_NRFX_CONCAT_,<sp/>NRFX_NUM_VA_ARGS_LESS_1(__VA_ARGS__))(__VA_ARGS__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="202"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="203"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>checking<sp/>if<sp/>argument<sp/>starts<sp/>with<sp/>opening<sp/>round<sp/>bracket<sp/>and<sp/>contains<sp/>matching</highlight></codeline>
<codeline lineno="204"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>closing<sp/>bracket<sp/>(parenthesis).</highlight></codeline>
<codeline lineno="205"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="206"><highlight class="comment"><sp/>*<sp/>@param[in]<sp/>x<sp/>Input<sp/>argument.</highlight></codeline>
<codeline lineno="207"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="208"><highlight class="comment"><sp/>*<sp/>@retval<sp/>1<sp/>If<sp/>input<sp/>argument<sp/>starts<sp/>with<sp/>opening<sp/>bracket<sp/>and<sp/>contains<sp/>closing<sp/>bracket.</highlight></codeline>
<codeline lineno="209"><highlight class="comment"><sp/>*<sp/>@retval<sp/>0<sp/>If<sp/>input<sp/>argument<sp/>does<sp/>not<sp/>match<sp/>above<sp/>mentioned<sp/>condition.</highlight></codeline>
<codeline lineno="210"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_ARG_HAS_PARENTHESIS(x)<sp/>_NRFX_GET_ARG3(_NRFX_EVAL(_NRFX_ARG_HAS_PARENTHESIS<sp/>x,<sp/>1,<sp/>0))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="213"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="214"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>calling<sp/>a<sp/>macro<sp/>@p<sp/>F<sp/>on<sp/>each<sp/>provided<sp/>argument<sp/>with<sp/>a<sp/>given</highlight></codeline>
<codeline lineno="215"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>separator<sp/>between<sp/>each<sp/>call.</highlight></codeline>
<codeline lineno="216"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="217"><highlight class="comment"><sp/>*<sp/>Example:</highlight></codeline>
<codeline lineno="218"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="219"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#define<sp/>F(x)<sp/>int<sp/>a##x</highlight></codeline>
<codeline lineno="220"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>NRFX_FOR_EACH(F,<sp/>(;),<sp/>4,<sp/>5,<sp/>6);</highlight></codeline>
<codeline lineno="221"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="222"><highlight class="comment"><sp/>*<sp/>This<sp/>expands<sp/>to:</highlight></codeline>
<codeline lineno="223"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="224"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a4;</highlight></codeline>
<codeline lineno="225"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a5;</highlight></codeline>
<codeline lineno="226"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a6;</highlight></codeline>
<codeline lineno="227"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="228"><highlight class="comment"><sp/>*<sp/>@param<sp/>F<sp/>Macro<sp/>to<sp/>invoke</highlight></codeline>
<codeline lineno="229"><highlight class="comment"><sp/>*<sp/>@param<sp/>sep<sp/>Separator<sp/>(e.g.<sp/>comma<sp/>or<sp/>semicolon).<sp/>Must<sp/>be<sp/>in<sp/>parentheses;</highlight></codeline>
<codeline lineno="230"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this<sp/>is<sp/>required<sp/>to<sp/>enable<sp/>providing<sp/>a<sp/>comma<sp/>as<sp/>a<sp/>separator.</highlight></codeline>
<codeline lineno="231"><highlight class="comment"><sp/>*<sp/>@param<sp/>...<sp/>Variable<sp/>argument<sp/>list.<sp/>The<sp/>macro<sp/>@p<sp/>F<sp/>is<sp/>invoked<sp/>as</highlight></codeline>
<codeline lineno="232"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;tt&gt;F(element)&lt;/tt&gt;<sp/>for<sp/>each<sp/>element<sp/>in<sp/>the<sp/>list.</highlight></codeline>
<codeline lineno="233"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_FOR_EACH(F,<sp/>sep,<sp/>...)<sp/>\</highlight></codeline>
<codeline lineno="235"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>_NRFX_FOR_EACH(F,<sp/>sep,<sp/>NRFX_REVERSE_ARGS(__VA_ARGS__))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="237"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="238"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Call<sp/>macro<sp/>@p<sp/>F<sp/>on<sp/>each<sp/>provided<sp/>argument,<sp/>with<sp/>the<sp/>argument&apos;s<sp/>index</highlight></codeline>
<codeline lineno="239"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>as<sp/>an<sp/>additional<sp/>parameter.</highlight></codeline>
<codeline lineno="240"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="241"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>like<sp/>@ref<sp/>NRFX_FOR_EACH(),<sp/>except<sp/>@p<sp/>F<sp/>should<sp/>be<sp/>a<sp/>macro<sp/>which<sp/>takes<sp/>two</highlight></codeline>
<codeline lineno="242"><highlight class="comment"><sp/>*<sp/>arguments:<sp/>&lt;tt&gt;F(index,<sp/>variable_arg)&lt;/tt&gt;.</highlight></codeline>
<codeline lineno="243"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="244"><highlight class="comment"><sp/>*<sp/>Example:</highlight></codeline>
<codeline lineno="245"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="246"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#define<sp/>F(idx,<sp/>x)<sp/>int<sp/>a##idx<sp/>=<sp/>x</highlight></codeline>
<codeline lineno="247"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>NRFX_FOR_EACH_IDX(F,<sp/>(;),<sp/>4,<sp/>5,<sp/>6);</highlight></codeline>
<codeline lineno="248"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="249"><highlight class="comment"><sp/>*<sp/>This<sp/>expands<sp/>to:</highlight></codeline>
<codeline lineno="250"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="251"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a0<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="252"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a1<sp/>=<sp/>5;</highlight></codeline>
<codeline lineno="253"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a2<sp/>=<sp/>6;</highlight></codeline>
<codeline lineno="254"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="255"><highlight class="comment"><sp/>*<sp/>@param<sp/>F<sp/>Macro<sp/>to<sp/>invoke</highlight></codeline>
<codeline lineno="256"><highlight class="comment"><sp/>*<sp/>@param<sp/>sep<sp/>Separator<sp/>(e.g.<sp/>comma<sp/>or<sp/>semicolon).<sp/>Must<sp/>be<sp/>in<sp/>parentheses;</highlight></codeline>
<codeline lineno="257"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this<sp/>is<sp/>required<sp/>to<sp/>enable<sp/>providing<sp/>a<sp/>comma<sp/>as<sp/>a<sp/>separator.</highlight></codeline>
<codeline lineno="258"><highlight class="comment"><sp/>*<sp/>@param<sp/>...<sp/>Variable<sp/>argument<sp/>list.<sp/>The<sp/>macro<sp/>@p<sp/>F<sp/>is<sp/>invoked<sp/>as</highlight></codeline>
<codeline lineno="259"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;tt&gt;F(index,<sp/>element)&lt;/tt&gt;<sp/>for<sp/>each<sp/>element<sp/>in<sp/>the<sp/>list.</highlight></codeline>
<codeline lineno="260"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="261"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_FOR_EACH_IDX(F,<sp/>sep,<sp/>...)<sp/>\</highlight></codeline>
<codeline lineno="262"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>_NRFX_FOR_EACH_IDX(F,<sp/>sep,<sp/>NRFX_REVERSE_ARGS(__VA_ARGS__))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="264"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="265"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>calling<sp/>macro<sp/>@p<sp/>F<sp/>on<sp/>each<sp/>provided<sp/>argument,<sp/>with<sp/>an<sp/>additional<sp/>fixed</highlight></codeline>
<codeline lineno="266"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>argument<sp/>as<sp/>a<sp/>parameter.</highlight></codeline>
<codeline lineno="267"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="268"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>like<sp/>@ref<sp/>NRFX_FOR_EACH(),<sp/>except<sp/>@p<sp/>F<sp/>should<sp/>be<sp/>a<sp/>macro<sp/>which<sp/>takes<sp/>two</highlight></codeline>
<codeline lineno="269"><highlight class="comment"><sp/>*<sp/>arguments:<sp/>&lt;tt&gt;F(variable_arg,<sp/>fixed_arg)&lt;/tt&gt;.</highlight></codeline>
<codeline lineno="270"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="271"><highlight class="comment"><sp/>*<sp/>Example:</highlight></codeline>
<codeline lineno="272"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="273"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>static<sp/>void<sp/>func(int<sp/>val,<sp/>void<sp/>*dev);</highlight></codeline>
<codeline lineno="274"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>NRFX_FOR_EACH_FIXED_ARG(func,<sp/>(;),<sp/>dev,<sp/>4,<sp/>5,<sp/>6);</highlight></codeline>
<codeline lineno="275"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="276"><highlight class="comment"><sp/>*<sp/>This<sp/>expands<sp/>to:</highlight></codeline>
<codeline lineno="277"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="278"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>func(4,<sp/>dev);</highlight></codeline>
<codeline lineno="279"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>func(5,<sp/>dev);</highlight></codeline>
<codeline lineno="280"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>func(6,<sp/>dev);</highlight></codeline>
<codeline lineno="281"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="282"><highlight class="comment"><sp/>*<sp/>@param<sp/>F<sp/>Macro<sp/>to<sp/>invoke</highlight></codeline>
<codeline lineno="283"><highlight class="comment"><sp/>*<sp/>@param<sp/>sep<sp/>Separator<sp/>(e.g.<sp/>comma<sp/>or<sp/>semicolon).<sp/>Must<sp/>be<sp/>in<sp/>parentheses;</highlight></codeline>
<codeline lineno="284"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>this<sp/>is<sp/>required<sp/>to<sp/>enable<sp/>providing<sp/>a<sp/>comma<sp/>as<sp/>a<sp/>separator.</highlight></codeline>
<codeline lineno="285"><highlight class="comment"><sp/>*<sp/>@param<sp/>fixed_arg<sp/>Fixed<sp/>argument<sp/>passed<sp/>to<sp/>@p<sp/>F<sp/>as<sp/>the<sp/>second<sp/>macro<sp/>parameter.</highlight></codeline>
<codeline lineno="286"><highlight class="comment"><sp/>*<sp/>@param<sp/>...<sp/>Variable<sp/>argument<sp/>list.<sp/>The<sp/>macro<sp/>@p<sp/>F<sp/>is<sp/>invoked<sp/>as</highlight></codeline>
<codeline lineno="287"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;tt&gt;F(element,<sp/>fixed_arg)&lt;/tt&gt;<sp/>for<sp/>each<sp/>element<sp/>in<sp/>the<sp/>list.</highlight></codeline>
<codeline lineno="288"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="289"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_FOR_EACH_FIXED_ARG(F,<sp/>sep,<sp/>fixed_arg,<sp/>...)<sp/>\</highlight></codeline>
<codeline lineno="290"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>_NRFX_FOR_EACH_FIXED_ARG(F,<sp/>sep,<sp/>fixed_arg,<sp/>NRFX_REVERSE_ARGS(__VA_ARGS__))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="292"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="293"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>from<sp/>calling<sp/>macro<sp/>@p<sp/>F<sp/>for<sp/>each<sp/>variable<sp/>argument<sp/>with<sp/>an<sp/>index<sp/>and<sp/>fixed</highlight></codeline>
<codeline lineno="294"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>argument</highlight></codeline>
<codeline lineno="295"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="296"><highlight class="comment"><sp/>*<sp/>This<sp/>is<sp/>like<sp/>the<sp/>combination<sp/>of<sp/>@ref<sp/>NRFX_FOR_EACH_IDX()<sp/>with<sp/>@ref<sp/>NRFX_FOR_EACH_FIXED_ARG().</highlight></codeline>
<codeline lineno="297"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="298"><highlight class="comment"><sp/>*<sp/>Example:</highlight></codeline>
<codeline lineno="299"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="300"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>#define<sp/>F(idx,<sp/>x,<sp/>fixed_arg)<sp/>int<sp/>fixed_arg##idx<sp/>=<sp/>x</highlight></codeline>
<codeline lineno="301"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>NRFX_FOR_EACH_IDX_FIXED_ARG(F,<sp/>(;),<sp/>a,<sp/>4,<sp/>5,<sp/>6);</highlight></codeline>
<codeline lineno="302"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="303"><highlight class="comment"><sp/>*<sp/>This<sp/>expands<sp/>to:</highlight></codeline>
<codeline lineno="304"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="305"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a0<sp/>=<sp/>4;</highlight></codeline>
<codeline lineno="306"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a1<sp/>=<sp/>5;</highlight></codeline>
<codeline lineno="307"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/>int<sp/>a2<sp/>=<sp/>6;</highlight></codeline>
<codeline lineno="308"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="309"><highlight class="comment"><sp/>*<sp/>@param<sp/>F<sp/>Macro<sp/>to<sp/>invoke</highlight></codeline>
<codeline lineno="310"><highlight class="comment"><sp/>*<sp/>@param<sp/>sep<sp/>Separator<sp/>(e.g.<sp/>comma<sp/>or<sp/>semicolon).<sp/>Must<sp/>be<sp/>in<sp/>parentheses;</highlight></codeline>
<codeline lineno="311"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>This<sp/>is<sp/>required<sp/>to<sp/>enable<sp/>providing<sp/>a<sp/>comma<sp/>as<sp/>a<sp/>separator.</highlight></codeline>
<codeline lineno="312"><highlight class="comment"><sp/>*<sp/>@param<sp/>fixed_arg<sp/>Fixed<sp/>argument<sp/>passed<sp/>to<sp/>@p<sp/>F<sp/>as<sp/>the<sp/>third<sp/>macro<sp/>parameter.</highlight></codeline>
<codeline lineno="313"><highlight class="comment"><sp/>*<sp/>@param<sp/>...<sp/>Variable<sp/>list<sp/>of<sp/>arguments.<sp/>The<sp/>macro<sp/>@p<sp/>F<sp/>is<sp/>invoked<sp/>as</highlight></codeline>
<codeline lineno="314"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;tt&gt;F(index,<sp/>element,<sp/>fixed_arg)&lt;/tt&gt;<sp/>for<sp/>each<sp/>element<sp/>in</highlight></codeline>
<codeline lineno="315"><highlight class="comment"><sp/>*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>the<sp/>list.</highlight></codeline>
<codeline lineno="316"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_FOR_EACH_IDX_FIXED_ARG(F,<sp/>sep,<sp/>fixed_arg,<sp/>...)<sp/>\</highlight></codeline>
<codeline lineno="318"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>_NRFX_FOR_EACH_IDX_FIXED_ARG(F,<sp/>sep,<sp/>fixed_arg,<sp/>NRFX_REVERSE_ARGS(__VA_ARGS__))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="320"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="321"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>reversing<sp/>arguments<sp/>order.</highlight></codeline>
<codeline lineno="322"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="323"><highlight class="comment"><sp/>*<sp/>@param<sp/>...<sp/>Variable<sp/>argument<sp/>list.</highlight></codeline>
<codeline lineno="324"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="325"><highlight class="comment"><sp/>*<sp/>@return<sp/>Input<sp/>arguments<sp/>in<sp/>reversed<sp/>order.</highlight></codeline>
<codeline lineno="326"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="327"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_REVERSE_ARGS(...)<sp/>\</highlight></codeline>
<codeline lineno="328"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>_NRFX_FOR_EACH_ENGINE(_NRFX_FOR_EACH_EXEC,<sp/>(,),<sp/>NRFX_EVAL,<sp/>_,<sp/>__VA_ARGS__)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="331"><highlight class="comment">/**</highlight></codeline>
<codeline lineno="332"><highlight class="comment"><sp/>*<sp/>@brief<sp/>Macro<sp/>for<sp/>getting<sp/>the<sp/>highest<sp/>value<sp/>from<sp/>input<sp/>arguments.</highlight></codeline>
<codeline lineno="333"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="334"><highlight class="comment"><sp/>*<sp/>It<sp/>is<sp/>similar<sp/>to<sp/>@ref<sp/>NRFX_MAX<sp/>but<sp/>accepts<sp/>a<sp/>variable<sp/>number<sp/>of<sp/>arguments.</highlight></codeline>
<codeline lineno="335"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="336"><highlight class="comment"><sp/>*<sp/>@note<sp/>Input<sp/>arguments<sp/>must<sp/>be<sp/>numeric<sp/>variables.</highlight></codeline>
<codeline lineno="337"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="338"><highlight class="comment"><sp/>*<sp/>@param<sp/>...<sp/>Variable<sp/>argument<sp/>list.</highlight></codeline>
<codeline lineno="339"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="340"><highlight class="comment"><sp/>*<sp/>@return<sp/>Highest<sp/>value<sp/>from<sp/>the<sp/>input<sp/>list.</highlight></codeline>
<codeline lineno="341"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>NRFX_MAX_N(...)<sp/>\</highlight></codeline>
<codeline lineno="343"><highlight class="preprocessor"><sp/><sp/><sp/><sp/>NRFX_EVAL(NRFX_FOR_EACH(_NRFX_MAX_P1,<sp/>(),<sp/>__VA_ARGS__)<sp/>0<sp/>\</highlight></codeline>
<codeline lineno="344"><highlight class="preprocessor"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>NRFX_FOR_EACH(_NRFX_MAX_P2,<sp/>(),<sp/>__VA_ARGS__))</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline lineno="346"><highlight class="comment">/**<sp/>@}<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="347"><highlight class="normal"></highlight></codeline>
<codeline lineno="348"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">/*<sp/>NRFX_UTILS_H__<sp/>*/</highlight><highlight class="preprocessor"></highlight></codeline>
    </programlisting>
    <location file="drivers/nrfx_utils.h"/>
  </compounddef>
</doxygen>
