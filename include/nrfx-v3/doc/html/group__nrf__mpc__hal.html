<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>nrfx 3.5: MPC HAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nrfx
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__nrf__mpc__hal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MPC HAL<div class="ingroups"><a class="el" href="group__nrfx__drivers.html">Drivers</a> &raquo; <a class="el" href="group__nrf__mpc.html">MPC</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Hardware access layer for managing the Memory Privilege Controller (MPC) peripheral.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__mpc__region__config__t.html">nrf_mpc_region_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Region configuration.  <a href="structnrf__mpc__region__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__mpc__override__config__t.html">nrf_mpc_override_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override region configuration.  <a href="structnrf__mpc__override__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga7be93b4931a85c0d99e1e57b3725bf62"><td class="memItemLeft" align="right" valign="top"><a id="ga7be93b4931a85c0d99e1e57b3725bf62" name="ga7be93b4931a85c0d99e1e57b3725bf62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NRF_MPC_HAS_RTCHOKE</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga7be93b4931a85c0d99e1e57b3725bf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol indicating whether RTCHOKE functionality is present. <br /></td></tr>
<tr class="separator:ga7be93b4931a85c0d99e1e57b3725bf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f21e5dc459acad0ea2d36f29b8037b"><td class="memItemLeft" align="right" valign="top"><a id="ga10f21e5dc459acad0ea2d36f29b8037b" name="ga10f21e5dc459acad0ea2d36f29b8037b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NRF_MPC_HAS_SECDOM</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga10f21e5dc459acad0ea2d36f29b8037b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol indicating whether SECDOM functionality is present. <br /></td></tr>
<tr class="separator:ga10f21e5dc459acad0ea2d36f29b8037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab273d8e3ac44dfb001e8dd37079e10ed"><td class="memItemLeft" align="right" valign="top"><a id="gab273d8e3ac44dfb001e8dd37079e10ed" name="gab273d8e3ac44dfb001e8dd37079e10ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NRF_MPC_HAS_OVERRIDE_OFFSET</b>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gab273d8e3ac44dfb001e8dd37079e10ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbol indicating whether OVERRIDE OFFSET functionality is present. <br /></td></tr>
<tr class="separator:gab273d8e3ac44dfb001e8dd37079e10ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e057328b822941974380fd47f35540"><td class="memItemLeft" align="right" valign="top"><a id="ga23e057328b822941974380fd47f35540" name="ga23e057328b822941974380fd47f35540"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NRF_MPC_REGION_COUNT</b>&#160;&#160;&#160;MPC_REGION_MaxCount</td></tr>
<tr class="memdesc:ga23e057328b822941974380fd47f35540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of regions. <br /></td></tr>
<tr class="separator:ga23e057328b822941974380fd47f35540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d9c129c96df36540f7e075aad3ad12"><td class="memItemLeft" align="right" valign="top"><a id="gad1d9c129c96df36540f7e075aad3ad12" name="gad1d9c129c96df36540f7e075aad3ad12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NRF_MPC_OVERRIDE_COUNT</b>&#160;&#160;&#160;MPC_OVERRIDE_MaxCount</td></tr>
<tr class="memdesc:gad1d9c129c96df36540f7e075aad3ad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of override regions. <br /></td></tr>
<tr class="separator:gad1d9c129c96df36540f7e075aad3ad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc595a5b1c0c672d60b76bb8b90d2c88"><td class="memItemLeft" align="right" valign="top"><a id="gabc595a5b1c0c672d60b76bb8b90d2c88" name="gabc595a5b1c0c672d60b76bb8b90d2c88"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NRF_MPC_MASTER_PORTS_COUNT</b>&#160;&#160;&#160;MPC_MASTER_PORTS_MaxCount</td></tr>
<tr class="memdesc:gabc595a5b1c0c672d60b76bb8b90d2c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of master ports. <br /></td></tr>
<tr class="separator:gabc595a5b1c0c672d60b76bb8b90d2c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61549ebb9c4c7beb97135757d0ea3b43"><td class="memItemLeft" align="right" valign="top"><a id="ga61549ebb9c4c7beb97135757d0ea3b43" name="ga61549ebb9c4c7beb97135757d0ea3b43"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>NRF_MPC_RTCHOKE_COUNT</b>&#160;&#160;&#160;MPC_RTCHOKE_DELAY_MaxCount</td></tr>
<tr class="memdesc:ga61549ebb9c4c7beb97135757d0ea3b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of Real Time Choke slaves. <br /></td></tr>
<tr class="separator:ga61549ebb9c4c7beb97135757d0ea3b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga934ee74ecdc1e369d8160adb9fc66720"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a> { <a class="el" href="group__nrf__mpc__hal.html#gga934ee74ecdc1e369d8160adb9fc66720a22af0570a23c55c1853b69faf805c232">NRF_MPC_EVENT_MEMACCERR</a> = offsetof(NRF_MPC_Type, EVENTS_MEMACCERR)
 }</td></tr>
<tr class="memdesc:ga934ee74ecdc1e369d8160adb9fc66720"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPC events.  <a href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">More...</a><br /></td></tr>
<tr class="separator:ga934ee74ecdc1e369d8160adb9fc66720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772315a021c75e1da4c2e3e063187507"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga772315a021c75e1da4c2e3e063187507">nrf_mpc_int_mask_t</a> { <a class="el" href="group__nrf__mpc__hal.html#gga772315a021c75e1da4c2e3e063187507ae01bcfb89be5b3c40fed1fc219d9643c">NRF_MPC_INT_MEMACCERR_MASK</a> = MPC_INTENSET_MEMACCERR_Msk
 }</td></tr>
<tr class="memdesc:ga772315a021c75e1da4c2e3e063187507"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPC interrupts.  <a href="group__nrf__mpc__hal.html#ga772315a021c75e1da4c2e3e063187507">More...</a><br /></td></tr>
<tr class="separator:ga772315a021c75e1da4c2e3e063187507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a52bbfed00c736a7ee0f49896fa4081"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga7a52bbfed00c736a7ee0f49896fa4081">nrf_mpc_errorsource_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga7a52bbfed00c736a7ee0f49896fa4081a64cb903a31aa57615e678d5c7d1eafa3">NRF_MPC_ERRORSOURCE_SLAVE</a> = MPC_MEMACCERR_INFO_ERRORSOURCE_Slave
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga7a52bbfed00c736a7ee0f49896fa4081aef720a89162160fcd8414c59dfe9256b">NRF_MPC_ERRORSOURCE_MPC</a> = MPC_MEMACCERR_INFO_ERRORSOURCE_MPC
<br />
 }</td></tr>
<tr class="memdesc:ga7a52bbfed00c736a7ee0f49896fa4081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error sources.  <a href="group__nrf__mpc__hal.html#ga7a52bbfed00c736a7ee0f49896fa4081">More...</a><br /></td></tr>
<tr class="separator:ga7a52bbfed00c736a7ee0f49896fa4081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7647978ee34cb4523182c945f58551b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga7647978ee34cb4523182c945f58551b9">nrf_mpc_permission_mask_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga7647978ee34cb4523182c945f58551b9a1c509f1ebed48d6867afccc726a4043b">NRF_MPC_PERM_READ_MASK</a> = MPC_OVERRIDE_PERM_READ_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga7647978ee34cb4523182c945f58551b9a558f07197637e5a0b8a2a2f921fd447d">NRF_MPC_PERM_WRITE_MASK</a> = MPC_OVERRIDE_PERM_WRITE_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga7647978ee34cb4523182c945f58551b9a79c6b09eb35c7aad331e55d236dd2c70">NRF_MPC_PERM_EXECUTE_MASK</a> = MPC_OVERRIDE_PERM_EXECUTE_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga7647978ee34cb4523182c945f58551b9a262e5d8389b70a706fc90ee7bedfc21b">NRF_MPC_PERM_SECURE_MASK</a> = MPC_OVERRIDE_PERM_SECATTR_Msk
<br />
 }</td></tr>
<tr class="memdesc:ga7647978ee34cb4523182c945f58551b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permissions mask.  <a href="group__nrf__mpc__hal.html#ga7647978ee34cb4523182c945f58551b9">More...</a><br /></td></tr>
<tr class="separator:ga7647978ee34cb4523182c945f58551b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89f734f107017134f3ff2c1136864626"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a43c186c29e44d048d4d7fe4ff28a652e">NRF_MPC_MASTERPORT_0_MASK</a> = MPC_REGION_MASTERPORT_ENABLE0_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a7de1a72c217938e2df33c57e5c1d1dfd">NRF_MPC_MASTERPORT_1_MASK</a> = MPC_REGION_MASTERPORT_ENABLE1_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a01c63fbb707890de841006fda673c7a0">NRF_MPC_MASTERPORT_2_MASK</a> = MPC_REGION_MASTERPORT_ENABLE2_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a2e60961c3d173af19e69bb72d89359b0">NRF_MPC_MASTERPORT_3_MASK</a> = MPC_REGION_MASTERPORT_ENABLE3_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a8d0d2f2319c6c8a0a03d5500cb3ec0e1">NRF_MPC_MASTERPORT_4_MASK</a> = MPC_REGION_MASTERPORT_ENABLE4_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626ae0c8a06e6520ffd7a128333b53eae1ed">NRF_MPC_MASTERPORT_5_MASK</a> = MPC_REGION_MASTERPORT_ENABLE5_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626aa78b1ac5e174da4d23be61d3d848c307">NRF_MPC_MASTERPORT_6_MASK</a> = MPC_REGION_MASTERPORT_ENABLE6_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a8436ed84236cfdc080dfd18607d3104d">NRF_MPC_MASTERPORT_7_MASK</a> = MPC_REGION_MASTERPORT_ENABLE7_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a3ccbfb54e1ef110e13b796eadeb099f1">NRF_MPC_MASTERPORT_8_MASK</a> = MPC_REGION_MASTERPORT_ENABLE8_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626ae9182adf98e9b7dd08cac1938fa4c3b8">NRF_MPC_MASTERPORT_9_MASK</a> = MPC_REGION_MASTERPORT_ENABLE9_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626aa53e7ec9f08170d9206c9f2af034ce1c">NRF_MPC_MASTERPORT_10_MASK</a> = MPC_REGION_MASTERPORT_ENABLE10_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a4f507e6bc4cb0b2470370bbd76d21276">NRF_MPC_MASTERPORT_11_MASK</a> = MPC_REGION_MASTERPORT_ENABLE11_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626aff37a9b46c2e54b063257ff36d20fb96">NRF_MPC_MASTERPORT_12_MASK</a> = MPC_REGION_MASTERPORT_ENABLE12_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a40a0275a3e23ae843380fd27b3d2a7d5">NRF_MPC_MASTERPORT_13_MASK</a> = MPC_REGION_MASTERPORT_ENABLE13_Msk
, <br />
&#160;&#160;<a class="el" href="group__nrf__mpc__hal.html#gga89f734f107017134f3ff2c1136864626a7b7cf1b2bf1f319c354013c347da4b28">NRF_MPC_MASTERPORT_14_MASK</a> = MPC_REGION_MASTERPORT_ENABLE14_Msk
<br />
 }</td></tr>
<tr class="memdesc:ga89f734f107017134f3ff2c1136864626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Masterport mask.  <a href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">More...</a><br /></td></tr>
<tr class="separator:ga89f734f107017134f3ff2c1136864626"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1efe7a5a8558565cc61d2c4f311d1cc1"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga1efe7a5a8558565cc61d2c4f311d1cc1">nrf_mpc_event_check</a> (NRF_MPC_Type const *p_reg, <a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a> event)</td></tr>
<tr class="memdesc:ga1efe7a5a8558565cc61d2c4f311d1cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving the state of the specified MPC event.  <br /></td></tr>
<tr class="separator:ga1efe7a5a8558565cc61d2c4f311d1cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa90d4919d314628db3a9c6d042715522"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gaa90d4919d314628db3a9c6d042715522">nrf_mpc_event_clear</a> (NRF_MPC_Type *p_reg, <a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a> event)</td></tr>
<tr class="memdesc:gaa90d4919d314628db3a9c6d042715522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for clearing the specified MPC event.  <br /></td></tr>
<tr class="separator:gaa90d4919d314628db3a9c6d042715522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3904ca723acf510699a41b86c45ff6ba"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga3904ca723acf510699a41b86c45ff6ba">nrf_mpc_event_address_get</a> (NRF_MPC_Type const *p_reg, <a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a> event)</td></tr>
<tr class="memdesc:ga3904ca723acf510699a41b86c45ff6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the address of the specified MPC event register.  <br /></td></tr>
<tr class="separator:ga3904ca723acf510699a41b86c45ff6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25ca9fe6b6ebcf95172d18727eee35c5"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga25ca9fe6b6ebcf95172d18727eee35c5">nrf_mpc_int_enable</a> (NRF_MPC_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:ga25ca9fe6b6ebcf95172d18727eee35c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the specified interrupts.  <br /></td></tr>
<tr class="separator:ga25ca9fe6b6ebcf95172d18727eee35c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e22f8e05eb85b0ed1b14654c93abd7f"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga1e22f8e05eb85b0ed1b14654c93abd7f">nrf_mpc_int_enable_check</a> (NRF_MPC_Type const *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:ga1e22f8e05eb85b0ed1b14654c93abd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if the specified interrupts are enabled.  <br /></td></tr>
<tr class="separator:ga1e22f8e05eb85b0ed1b14654c93abd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40309fcc06c2cac4f55186a6c093042"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gaf40309fcc06c2cac4f55186a6c093042">nrf_mpc_int_disable</a> (NRF_MPC_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:gaf40309fcc06c2cac4f55186a6c093042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling the specified interrupts.  <br /></td></tr>
<tr class="separator:gaf40309fcc06c2cac4f55186a6c093042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbff5f9ce331b63da982ea340f425c9a"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gacbff5f9ce331b63da982ea340f425c9a">nrf_mpc_region_config_set</a> (NRF_MPC_Type *p_reg, uint8_t index, <a class="el" href="structnrf__mpc__region__config__t.html">nrf_mpc_region_config_t</a> const *p_config)</td></tr>
<tr class="memdesc:gacbff5f9ce331b63da982ea340f425c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting configuration of the region.  <br /></td></tr>
<tr class="separator:gacbff5f9ce331b63da982ea340f425c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab554feb151d3a8a84aa1ef49985b24b8"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE <a class="el" href="structnrf__mpc__region__config__t.html">nrf_mpc_region_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gab554feb151d3a8a84aa1ef49985b24b8">nrf_mpc_region_config_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gab554feb151d3a8a84aa1ef49985b24b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting configuration of the region.  <br /></td></tr>
<tr class="separator:gab554feb151d3a8a84aa1ef49985b24b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7157d67ae0a98e234ee019202d106c40"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga7157d67ae0a98e234ee019202d106c40">nrf_mpc_region_startaddr_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t address)</td></tr>
<tr class="memdesc:ga7157d67ae0a98e234ee019202d106c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting start address of the region.  <br /></td></tr>
<tr class="separator:ga7157d67ae0a98e234ee019202d106c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32f4b879381393d713cce3491fb1e57a"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga32f4b879381393d713cce3491fb1e57a">nrf_mpc_region_startaddr_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:ga32f4b879381393d713cce3491fb1e57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting start address of the region.  <br /></td></tr>
<tr class="separator:ga32f4b879381393d713cce3491fb1e57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22f8d9a1f3e4fd561edbbdb88e143f6a"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga22f8d9a1f3e4fd561edbbdb88e143f6a">nrf_mpc_region_addrmask_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t address)</td></tr>
<tr class="memdesc:ga22f8d9a1f3e4fd561edbbdb88e143f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting address mask of the region.  <br /></td></tr>
<tr class="separator:ga22f8d9a1f3e4fd561edbbdb88e143f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5cffc828be3aca6ebdeac0461001f90"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gae5cffc828be3aca6ebdeac0461001f90">nrf_mpc_region_addrmask_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gae5cffc828be3aca6ebdeac0461001f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting address mask of the region.  <br /></td></tr>
<tr class="separator:gae5cffc828be3aca6ebdeac0461001f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447c3ac18526b96414f7222acf308d75"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga447c3ac18526b96414f7222acf308d75">nrf_mpc_region_masterport_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t mask)</td></tr>
<tr class="memdesc:ga447c3ac18526b96414f7222acf308d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the specified master ports of the region.  <br /></td></tr>
<tr class="separator:ga447c3ac18526b96414f7222acf308d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ead7ef46873e85ffff2a217a3f1cd4"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gaf2ead7ef46873e85ffff2a217a3f1cd4">nrf_mpc_region_masterport_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gaf2ead7ef46873e85ffff2a217a3f1cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting enabled master ports of the region.  <br /></td></tr>
<tr class="separator:gaf2ead7ef46873e85ffff2a217a3f1cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c507026fa171618a79101c6233ca8b"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga39c507026fa171618a79101c6233ca8b">nrf_mpc_override_config_set</a> (NRF_MPC_Type *p_reg, uint8_t index, <a class="el" href="structnrf__mpc__override__config__t.html">nrf_mpc_override_config_t</a> const *p_config)</td></tr>
<tr class="memdesc:ga39c507026fa171618a79101c6233ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting configuration of the override region.  <br /></td></tr>
<tr class="separator:ga39c507026fa171618a79101c6233ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac007fe07342b8eecba4932d41ed0efec"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE <a class="el" href="structnrf__mpc__override__config__t.html">nrf_mpc_override_config_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gac007fe07342b8eecba4932d41ed0efec">nrf_mpc_override_config_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gac007fe07342b8eecba4932d41ed0efec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting configuration of the override region.  <br /></td></tr>
<tr class="separator:gac007fe07342b8eecba4932d41ed0efec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga860c13495b30810658e923daae9307c9"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga860c13495b30810658e923daae9307c9">nrf_mpc_override_startaddr_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t address)</td></tr>
<tr class="memdesc:ga860c13495b30810658e923daae9307c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting start address of the override region.  <br /></td></tr>
<tr class="separator:ga860c13495b30810658e923daae9307c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d4c0b94e029e5c76125e12dee391cc"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gae3d4c0b94e029e5c76125e12dee391cc">nrf_mpc_override_startaddr_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gae3d4c0b94e029e5c76125e12dee391cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting start address of the override region.  <br /></td></tr>
<tr class="separator:gae3d4c0b94e029e5c76125e12dee391cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3788c87dd9420235f8965883202c9c78"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga3788c87dd9420235f8965883202c9c78">nrf_mpc_override_endaddr_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t address)</td></tr>
<tr class="memdesc:ga3788c87dd9420235f8965883202c9c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting end address of the override region.  <br /></td></tr>
<tr class="separator:ga3788c87dd9420235f8965883202c9c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05d65c913a5fa0c53ea112257da7969"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gac05d65c913a5fa0c53ea112257da7969">nrf_mpc_override_endaddr_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gac05d65c913a5fa0c53ea112257da7969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting end address of the override region.  <br /></td></tr>
<tr class="separator:gac05d65c913a5fa0c53ea112257da7969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4360714e10c9b3a46f342b9084b34911"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga4360714e10c9b3a46f342b9084b34911">nrf_mpc_override_offset_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t offset)</td></tr>
<tr class="memdesc:ga4360714e10c9b3a46f342b9084b34911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting offset of the override region.  <br /></td></tr>
<tr class="separator:ga4360714e10c9b3a46f342b9084b34911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebfa2cf1848130f9c4bc17c814545e1a"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gaebfa2cf1848130f9c4bc17c814545e1a">nrf_mpc_override_offset_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gaebfa2cf1848130f9c4bc17c814545e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting offset of the override region.  <br /></td></tr>
<tr class="separator:gaebfa2cf1848130f9c4bc17c814545e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga765e067757c5e85d628788848163ee95"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga765e067757c5e85d628788848163ee95">nrf_mpc_override_perm_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t permissions)</td></tr>
<tr class="memdesc:ga765e067757c5e85d628788848163ee95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting permission settings for the override region.  <br /></td></tr>
<tr class="separator:ga765e067757c5e85d628788848163ee95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafced42e6003285cc6b93aef32c08715e"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gafced42e6003285cc6b93aef32c08715e">nrf_mpc_override_perm_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:gafced42e6003285cc6b93aef32c08715e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting permission settings of the override region.  <br /></td></tr>
<tr class="separator:gafced42e6003285cc6b93aef32c08715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9baa4d2ef6d04d3c6125f2ed9493aaf5"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga9baa4d2ef6d04d3c6125f2ed9493aaf5">nrf_mpc_override_permmask_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t permissions)</td></tr>
<tr class="memdesc:ga9baa4d2ef6d04d3c6125f2ed9493aaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting permission settings mask for the override region.  <br /></td></tr>
<tr class="separator:ga9baa4d2ef6d04d3c6125f2ed9493aaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13a7fe4a399c7d24fcf9f9c7788c09c1"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga13a7fe4a399c7d24fcf9f9c7788c09c1">nrf_mpc_override_permmask_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:ga13a7fe4a399c7d24fcf9f9c7788c09c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting permission settings mask of the override region.  <br /></td></tr>
<tr class="separator:ga13a7fe4a399c7d24fcf9f9c7788c09c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd600b1d367f88e6181ec42e9c1f842"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga0fd600b1d367f88e6181ec42e9c1f842">nrf_mpc_override_ownerid_set</a> (NRF_MPC_Type *p_reg, uint8_t index, nrf_owner_t owner_id)</td></tr>
<tr class="memdesc:ga0fd600b1d367f88e6181ec42e9c1f842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting owner ID for the override region.  <br /></td></tr>
<tr class="separator:ga0fd600b1d367f88e6181ec42e9c1f842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36bb427a4979cd656667b8a08ad55ff4"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE nrf_owner_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga36bb427a4979cd656667b8a08ad55ff4">nrf_mpc_override_ownerid_get</a> (NRF_MPC_Type *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:ga36bb427a4979cd656667b8a08ad55ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting owner ID of the override region.  <br /></td></tr>
<tr class="separator:ga36bb427a4979cd656667b8a08ad55ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae79fb68d0f2cdb8bab520731e25b38e9"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gae79fb68d0f2cdb8bab520731e25b38e9">nrf_mpc_override_masterport_set</a> (NRF_MPC_Type *p_reg, uint8_t index, uint32_t mask)</td></tr>
<tr class="memdesc:gae79fb68d0f2cdb8bab520731e25b38e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the specified master ports of the override region.  <br /></td></tr>
<tr class="separator:gae79fb68d0f2cdb8bab520731e25b38e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398b9aad20b0735a4ada32812a3dd3d0"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga398b9aad20b0735a4ada32812a3dd3d0">nrf_mpc_override_masterport_get</a> (NRF_MPC_Type const *p_reg, uint8_t index)</td></tr>
<tr class="memdesc:ga398b9aad20b0735a4ada32812a3dd3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting enabled master ports of the override region.  <br /></td></tr>
<tr class="separator:ga398b9aad20b0735a4ada32812a3dd3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef975d68f3bb54b021d37ba1d64c9ce"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gaaef975d68f3bb54b021d37ba1d64c9ce">nrf_mpc_memaccerr_address_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:gaaef975d68f3bb54b021d37ba1d64c9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the memory address of memory access error.  <br /></td></tr>
<tr class="separator:gaaef975d68f3bb54b021d37ba1d64c9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b52f80f1b3190f2630418b740a8abbb"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE nrf_owner_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga7b52f80f1b3190f2630418b740a8abbb">nrf_mpc_memaccerr_info_ownerid_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:ga7b52f80f1b3190f2630418b740a8abbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the owner identifier of the transaction that triggered memory access error.  <br /></td></tr>
<tr class="separator:ga7b52f80f1b3190f2630418b740a8abbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga788b2a97dba99dfa03f09ef727c178d5"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga788b2a97dba99dfa03f09ef727c178d5">nrf_mpc_memaccerr_info_masterport_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:ga788b2a97dba99dfa03f09ef727c178d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the master port of the transaction that triggered memory access error.  <br /></td></tr>
<tr class="separator:ga788b2a97dba99dfa03f09ef727c178d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca19e5b26e7b6504cc179e01ed93f05"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gaeca19e5b26e7b6504cc179e01ed93f05">nrf_mpc_memaccerr_info_perm_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:gaeca19e5b26e7b6504cc179e01ed93f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the permissions of the transaction that triggered memory access error.  <br /></td></tr>
<tr class="separator:gaeca19e5b26e7b6504cc179e01ed93f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5eedb315b47a18f9965755353a60f31"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE <a class="el" href="group__nrf__mpc__hal.html#ga7a52bbfed00c736a7ee0f49896fa4081">nrf_mpc_errorsource_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gad5eedb315b47a18f9965755353a60f31">nrf_mpc_memaccerr_info_errorsource_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:gad5eedb315b47a18f9965755353a60f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the source of the transaction that triggered memory access error.  <br /></td></tr>
<tr class="separator:gad5eedb315b47a18f9965755353a60f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeec50c60a288767deb1587481edbe762"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gaeec50c60a288767deb1587481edbe762">nrf_mpc_globalslave_masterport_set</a> (NRF_MPC_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:gaeec50c60a288767deb1587481edbe762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the specified master ports connection to global slave.  <br /></td></tr>
<tr class="separator:gaeec50c60a288767deb1587481edbe762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aae47ddb1607ea45e94b1f8bd281e85"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga0aae47ddb1607ea45e94b1f8bd281e85">nrf_mpc_globalslave_masterport_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:ga0aae47ddb1607ea45e94b1f8bd281e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting enabled master ports connection to global slave.  <br /></td></tr>
<tr class="separator:ga0aae47ddb1607ea45e94b1f8bd281e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6edfd83d8f3f243e4637a3152d829f7"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gae6edfd83d8f3f243e4637a3152d829f7">nrf_mpc_globalslave_lock_enable</a> (NRF_MPC_Type *p_reg)</td></tr>
<tr class="memdesc:gae6edfd83d8f3f243e4637a3152d829f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the global slave registers lock.  <br /></td></tr>
<tr class="separator:gae6edfd83d8f3f243e4637a3152d829f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6e9ce5f593eca645894a5d5ca0aa1e"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga6a6e9ce5f593eca645894a5d5ca0aa1e">nrf_mpc_globalslave_lock_check</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:ga6a6e9ce5f593eca645894a5d5ca0aa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the status of the global slave registers lock.  <br /></td></tr>
<tr class="separator:ga6a6e9ce5f593eca645894a5d5ca0aa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac611c03b4cabceedf8df9694361a6f66"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gac611c03b4cabceedf8df9694361a6f66">nrf_mpc_rtchoke_writeaccess_set</a> (NRF_MPC_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:gac611c03b4cabceedf8df9694361a6f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the AXI Write Address Channel Real Time Choke for specified master ports.  <br /></td></tr>
<tr class="separator:gac611c03b4cabceedf8df9694361a6f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ddf36ab7898e4415c2a2334198598d5"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga2ddf36ab7898e4415c2a2334198598d5">nrf_mpc_rtchoke_writeaccess_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:ga2ddf36ab7898e4415c2a2334198598d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting master ports with enabled AXI Write Address Channel Real Time Choke.  <br /></td></tr>
<tr class="separator:ga2ddf36ab7898e4415c2a2334198598d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13bb38ea31028aae2aac0ee3e091b21e"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga13bb38ea31028aae2aac0ee3e091b21e">nrf_mpc_rtchoke_readaccess_set</a> (NRF_MPC_Type *p_reg, uint32_t mask)</td></tr>
<tr class="memdesc:ga13bb38ea31028aae2aac0ee3e091b21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the AXI Read Address Channel Real Time Choke for specified master ports.  <br /></td></tr>
<tr class="separator:ga13bb38ea31028aae2aac0ee3e091b21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e448fe5c32baa27c83d191623623249"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga5e448fe5c32baa27c83d191623623249">nrf_mpc_rtchoke_readaccess_get</a> (NRF_MPC_Type const *p_reg)</td></tr>
<tr class="memdesc:ga5e448fe5c32baa27c83d191623623249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting master ports with enabled AXI Read Address Channel Real Time Choke.  <br /></td></tr>
<tr class="separator:ga5e448fe5c32baa27c83d191623623249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8417da63a1d979fbb0640f5863c4324"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#gad8417da63a1d979fbb0640f5863c4324">nrf_mpc_rtchoke_delay_set</a> (NRF_MPC_Type *p_reg, uint8_t slave, uint8_t delay)</td></tr>
<tr class="memdesc:gad8417da63a1d979fbb0640f5863c4324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting the Real Time Choke delay for the specified slave.  <br /></td></tr>
<tr class="separator:gad8417da63a1d979fbb0640f5863c4324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga175f2577dab13295cdaec1156517ba2c"><td class="memItemLeft" align="right" valign="top">NRF_STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__mpc__hal.html#ga175f2577dab13295cdaec1156517ba2c">nrf_mpc_rtchoke_delay_get</a> (NRF_MPC_Type const *p_reg, uint8_t slave)</td></tr>
<tr class="memdesc:ga175f2577dab13295cdaec1156517ba2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the Real Time Choke delay for the specified slave.  <br /></td></tr>
<tr class="separator:ga175f2577dab13295cdaec1156517ba2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Hardware access layer for managing the Memory Privilege Controller (MPC) peripheral. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7a52bbfed00c736a7ee0f49896fa4081" name="ga7a52bbfed00c736a7ee0f49896fa4081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a52bbfed00c736a7ee0f49896fa4081">&#9670;&#160;</a></span>nrf_mpc_errorsource_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__mpc__hal.html#ga7a52bbfed00c736a7ee0f49896fa4081">nrf_mpc_errorsource_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error sources. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7a52bbfed00c736a7ee0f49896fa4081a64cb903a31aa57615e678d5c7d1eafa3" name="gga7a52bbfed00c736a7ee0f49896fa4081a64cb903a31aa57615e678d5c7d1eafa3"></a>NRF_MPC_ERRORSOURCE_SLAVE&#160;</td><td class="fielddoc"><p>Error was triggered by an AXI slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7a52bbfed00c736a7ee0f49896fa4081aef720a89162160fcd8414c59dfe9256b" name="gga7a52bbfed00c736a7ee0f49896fa4081aef720a89162160fcd8414c59dfe9256b"></a>NRF_MPC_ERRORSOURCE_MPC&#160;</td><td class="fielddoc"><p>Error was triggered by MCP module. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga934ee74ecdc1e369d8160adb9fc66720" name="ga934ee74ecdc1e369d8160adb9fc66720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga934ee74ecdc1e369d8160adb9fc66720">&#9670;&#160;</a></span>nrf_mpc_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MPC events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga934ee74ecdc1e369d8160adb9fc66720a22af0570a23c55c1853b69faf805c232" name="gga934ee74ecdc1e369d8160adb9fc66720a22af0570a23c55c1853b69faf805c232"></a>NRF_MPC_EVENT_MEMACCERR&#160;</td><td class="fielddoc"><p>Memory access error. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga772315a021c75e1da4c2e3e063187507" name="ga772315a021c75e1da4c2e3e063187507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga772315a021c75e1da4c2e3e063187507">&#9670;&#160;</a></span>nrf_mpc_int_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__mpc__hal.html#ga772315a021c75e1da4c2e3e063187507">nrf_mpc_int_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MPC interrupts. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga772315a021c75e1da4c2e3e063187507ae01bcfb89be5b3c40fed1fc219d9643c" name="gga772315a021c75e1da4c2e3e063187507ae01bcfb89be5b3c40fed1fc219d9643c"></a>NRF_MPC_INT_MEMACCERR_MASK&#160;</td><td class="fielddoc"><p>Interrupt on MEMACCERR event. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga89f734f107017134f3ff2c1136864626" name="ga89f734f107017134f3ff2c1136864626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89f734f107017134f3ff2c1136864626">&#9670;&#160;</a></span>nrf_mpc_masterport_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Masterport mask. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a43c186c29e44d048d4d7fe4ff28a652e" name="gga89f734f107017134f3ff2c1136864626a43c186c29e44d048d4d7fe4ff28a652e"></a>NRF_MPC_MASTERPORT_0_MASK&#160;</td><td class="fielddoc"><p>Enable master port 0. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a7de1a72c217938e2df33c57e5c1d1dfd" name="gga89f734f107017134f3ff2c1136864626a7de1a72c217938e2df33c57e5c1d1dfd"></a>NRF_MPC_MASTERPORT_1_MASK&#160;</td><td class="fielddoc"><p>Enable master port 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a01c63fbb707890de841006fda673c7a0" name="gga89f734f107017134f3ff2c1136864626a01c63fbb707890de841006fda673c7a0"></a>NRF_MPC_MASTERPORT_2_MASK&#160;</td><td class="fielddoc"><p>Enable master port 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a2e60961c3d173af19e69bb72d89359b0" name="gga89f734f107017134f3ff2c1136864626a2e60961c3d173af19e69bb72d89359b0"></a>NRF_MPC_MASTERPORT_3_MASK&#160;</td><td class="fielddoc"><p>Enable master port 3. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a8d0d2f2319c6c8a0a03d5500cb3ec0e1" name="gga89f734f107017134f3ff2c1136864626a8d0d2f2319c6c8a0a03d5500cb3ec0e1"></a>NRF_MPC_MASTERPORT_4_MASK&#160;</td><td class="fielddoc"><p>Enable master port 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626ae0c8a06e6520ffd7a128333b53eae1ed" name="gga89f734f107017134f3ff2c1136864626ae0c8a06e6520ffd7a128333b53eae1ed"></a>NRF_MPC_MASTERPORT_5_MASK&#160;</td><td class="fielddoc"><p>Enable master port 5. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626aa78b1ac5e174da4d23be61d3d848c307" name="gga89f734f107017134f3ff2c1136864626aa78b1ac5e174da4d23be61d3d848c307"></a>NRF_MPC_MASTERPORT_6_MASK&#160;</td><td class="fielddoc"><p>Enable master port 6. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a8436ed84236cfdc080dfd18607d3104d" name="gga89f734f107017134f3ff2c1136864626a8436ed84236cfdc080dfd18607d3104d"></a>NRF_MPC_MASTERPORT_7_MASK&#160;</td><td class="fielddoc"><p>Enable master port 7. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a3ccbfb54e1ef110e13b796eadeb099f1" name="gga89f734f107017134f3ff2c1136864626a3ccbfb54e1ef110e13b796eadeb099f1"></a>NRF_MPC_MASTERPORT_8_MASK&#160;</td><td class="fielddoc"><p>Enable master port 8. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626ae9182adf98e9b7dd08cac1938fa4c3b8" name="gga89f734f107017134f3ff2c1136864626ae9182adf98e9b7dd08cac1938fa4c3b8"></a>NRF_MPC_MASTERPORT_9_MASK&#160;</td><td class="fielddoc"><p>Enable master port 9. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626aa53e7ec9f08170d9206c9f2af034ce1c" name="gga89f734f107017134f3ff2c1136864626aa53e7ec9f08170d9206c9f2af034ce1c"></a>NRF_MPC_MASTERPORT_10_MASK&#160;</td><td class="fielddoc"><p>Enable master port 10. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a4f507e6bc4cb0b2470370bbd76d21276" name="gga89f734f107017134f3ff2c1136864626a4f507e6bc4cb0b2470370bbd76d21276"></a>NRF_MPC_MASTERPORT_11_MASK&#160;</td><td class="fielddoc"><p>Enable master port 11. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626aff37a9b46c2e54b063257ff36d20fb96" name="gga89f734f107017134f3ff2c1136864626aff37a9b46c2e54b063257ff36d20fb96"></a>NRF_MPC_MASTERPORT_12_MASK&#160;</td><td class="fielddoc"><p>Enable master port 12. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a40a0275a3e23ae843380fd27b3d2a7d5" name="gga89f734f107017134f3ff2c1136864626a40a0275a3e23ae843380fd27b3d2a7d5"></a>NRF_MPC_MASTERPORT_13_MASK&#160;</td><td class="fielddoc"><p>Enable master port 13. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga89f734f107017134f3ff2c1136864626a7b7cf1b2bf1f319c354013c347da4b28" name="gga89f734f107017134f3ff2c1136864626a7b7cf1b2bf1f319c354013c347da4b28"></a>NRF_MPC_MASTERPORT_14_MASK&#160;</td><td class="fielddoc"><p>Enable master port 14. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7647978ee34cb4523182c945f58551b9" name="ga7647978ee34cb4523182c945f58551b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7647978ee34cb4523182c945f58551b9">&#9670;&#160;</a></span>nrf_mpc_permission_mask_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__mpc__hal.html#ga7647978ee34cb4523182c945f58551b9">nrf_mpc_permission_mask_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permissions mask. </p>
<dl class="section note"><dt>Note</dt><dd>This enum may be used for both permission settings and permission settings mask. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7647978ee34cb4523182c945f58551b9a1c509f1ebed48d6867afccc726a4043b" name="gga7647978ee34cb4523182c945f58551b9a1c509f1ebed48d6867afccc726a4043b"></a>NRF_MPC_PERM_READ_MASK&#160;</td><td class="fielddoc"><p>Read access. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7647978ee34cb4523182c945f58551b9a558f07197637e5a0b8a2a2f921fd447d" name="gga7647978ee34cb4523182c945f58551b9a558f07197637e5a0b8a2a2f921fd447d"></a>NRF_MPC_PERM_WRITE_MASK&#160;</td><td class="fielddoc"><p>Write access. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7647978ee34cb4523182c945f58551b9a79c6b09eb35c7aad331e55d236dd2c70" name="gga7647978ee34cb4523182c945f58551b9a79c6b09eb35c7aad331e55d236dd2c70"></a>NRF_MPC_PERM_EXECUTE_MASK&#160;</td><td class="fielddoc"><p>Software execute. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7647978ee34cb4523182c945f58551b9a262e5d8389b70a706fc90ee7bedfc21b" name="gga7647978ee34cb4523182c945f58551b9a262e5d8389b70a706fc90ee7bedfc21b"></a>NRF_MPC_PERM_SECURE_MASK&#160;</td><td class="fielddoc"><p>Security mapping. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3904ca723acf510699a41b86c45ff6ba" name="ga3904ca723acf510699a41b86c45ff6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3904ca723acf510699a41b86c45ff6ba">&#9670;&#160;</a></span>nrf_mpc_event_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_event_address_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the address of the specified MPC event register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event to get the address of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the specified event register. </dd></dl>

</div>
</div>
<a id="ga1efe7a5a8558565cc61d2c4f311d1cc1" name="ga1efe7a5a8558565cc61d2c4f311d1cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1efe7a5a8558565cc61d2c4f311d1cc1">&#9670;&#160;</a></span>nrf_mpc_event_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_mpc_event_check </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving the state of the specified MPC event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The event has been generated. </td></tr>
    <tr><td class="paramname">false</td><td>The event has not been generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa90d4919d314628db3a9c6d042715522" name="gaa90d4919d314628db3a9c6d042715522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa90d4919d314628db3a9c6d042715522">&#9670;&#160;</a></span>nrf_mpc_event_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_event_clear </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__mpc__hal.html#ga934ee74ecdc1e369d8160adb9fc66720">nrf_mpc_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for clearing the specified MPC event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event to be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a6e9ce5f593eca645894a5d5ca0aa1e" name="ga6a6e9ce5f593eca645894a5d5ca0aa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6e9ce5f593eca645894a5d5ca0aa1e">&#9670;&#160;</a></span>nrf_mpc_globalslave_lock_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE bool nrf_mpc_globalslave_lock_check </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the status of the global slave registers lock. </p>
<dl class="section note"><dt>Note</dt><dd>When global slave registers is enabled, modifying the global slave configuration is not possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if global slave registers are locked, false otherwise. </dd></dl>

</div>
</div>
<a id="gae6edfd83d8f3f243e4637a3152d829f7" name="gae6edfd83d8f3f243e4637a3152d829f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6edfd83d8f3f243e4637a3152d829f7">&#9670;&#160;</a></span>nrf_mpc_globalslave_lock_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_globalslave_lock_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the global slave registers lock. </p>
<dl class="section note"><dt>Note</dt><dd>When global slave registers is enabled, modifying the global slave configuration is not possible.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0aae47ddb1607ea45e94b1f8bd281e85" name="ga0aae47ddb1607ea45e94b1f8bd281e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aae47ddb1607ea45e94b1f8bd281e85">&#9670;&#160;</a></span>nrf_mpc_globalslave_masterport_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_globalslave_masterport_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting enabled master ports connection to global slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of master ports connected, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </dd></dl>

</div>
</div>
<a id="gaeec50c60a288767deb1587481edbe762" name="gaeec50c60a288767deb1587481edbe762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeec50c60a288767deb1587481edbe762">&#9670;&#160;</a></span>nrf_mpc_globalslave_masterport_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_globalslave_masterport_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the specified master ports connection to global slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of master ports to be connected, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf40309fcc06c2cac4f55186a6c093042" name="gaf40309fcc06c2cac4f55186a6c093042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf40309fcc06c2cac4f55186a6c093042">&#9670;&#160;</a></span>nrf_mpc_int_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_int_disable </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling the specified interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of interrupts to be disabled. Use <a class="el" href="group__nrf__mpc__hal.html#ga772315a021c75e1da4c2e3e063187507">nrf_mpc_int_mask_t</a> values for bit masking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25ca9fe6b6ebcf95172d18727eee35c5" name="ga25ca9fe6b6ebcf95172d18727eee35c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25ca9fe6b6ebcf95172d18727eee35c5">&#9670;&#160;</a></span>nrf_mpc_int_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_int_enable </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the specified interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of interrupts to be enabled. Use <a class="el" href="group__nrf__mpc__hal.html#ga772315a021c75e1da4c2e3e063187507">nrf_mpc_int_mask_t</a> values for bit masking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e22f8e05eb85b0ed1b14654c93abd7f" name="ga1e22f8e05eb85b0ed1b14654c93abd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e22f8e05eb85b0ed1b14654c93abd7f">&#9670;&#160;</a></span>nrf_mpc_int_enable_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_int_enable_check </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if the specified interrupts are enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of interrupts to be checked. Use <a class="el" href="group__nrf__mpc__hal.html#ga772315a021c75e1da4c2e3e063187507">nrf_mpc_int_mask_t</a> values for bit masking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of enabled interrupts. </dd></dl>

</div>
</div>
<a id="gaaef975d68f3bb54b021d37ba1d64c9ce" name="gaaef975d68f3bb54b021d37ba1d64c9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaef975d68f3bb54b021d37ba1d64c9ce">&#9670;&#160;</a></span>nrf_mpc_memaccerr_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_memaccerr_address_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the memory address of memory access error. </p>
<dl class="section note"><dt>Note</dt><dd>Register content will not be changed as long as MEMACCERR event is active.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Target address for the errroneous access. </dd></dl>

</div>
</div>
<a id="gad5eedb315b47a18f9965755353a60f31" name="gad5eedb315b47a18f9965755353a60f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5eedb315b47a18f9965755353a60f31">&#9670;&#160;</a></span>nrf_mpc_memaccerr_info_errorsource_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE <a class="el" href="group__nrf__mpc__hal.html#ga7a52bbfed00c736a7ee0f49896fa4081">nrf_mpc_errorsource_t</a> nrf_mpc_memaccerr_info_errorsource_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the source of the transaction that triggered memory access error. </p>
<dl class="section note"><dt>Note</dt><dd>Register content will not be changed as long as MEMACCERR event is active.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Source of the errorneous access. </dd></dl>

</div>
</div>
<a id="ga788b2a97dba99dfa03f09ef727c178d5" name="ga788b2a97dba99dfa03f09ef727c178d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga788b2a97dba99dfa03f09ef727c178d5">&#9670;&#160;</a></span>nrf_mpc_memaccerr_info_masterport_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint8_t nrf_mpc_memaccerr_info_masterport_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the master port of the transaction that triggered memory access error. </p>
<dl class="section note"><dt>Note</dt><dd>Register content will not be changed as long as MEMACCERR event is active.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Master port where errorneous access is detected. </dd></dl>

</div>
</div>
<a id="ga7b52f80f1b3190f2630418b740a8abbb" name="ga7b52f80f1b3190f2630418b740a8abbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b52f80f1b3190f2630418b740a8abbb">&#9670;&#160;</a></span>nrf_mpc_memaccerr_info_ownerid_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE nrf_owner_t nrf_mpc_memaccerr_info_ownerid_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the owner identifier of the transaction that triggered memory access error. </p>
<dl class="section note"><dt>Note</dt><dd>Register content will not be changed as long as MEMACCERR event is active.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Owner identifier of the errorneous access. </dd></dl>

</div>
</div>
<a id="gaeca19e5b26e7b6504cc179e01ed93f05" name="gaeca19e5b26e7b6504cc179e01ed93f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeca19e5b26e7b6504cc179e01ed93f05">&#9670;&#160;</a></span>nrf_mpc_memaccerr_info_perm_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_memaccerr_info_perm_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the permissions of the transaction that triggered memory access error. </p>
<dl class="section note"><dt>Note</dt><dd>Register content will not be changed as long as MEMACCERR event is active.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Permission settings of the errorneous access. </dd></dl>

</div>
</div>
<a id="gac007fe07342b8eecba4932d41ed0efec" name="gac007fe07342b8eecba4932d41ed0efec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac007fe07342b8eecba4932d41ed0efec">&#9670;&#160;</a></span>nrf_mpc_override_config_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE <a class="el" href="structnrf__mpc__override__config__t.html">nrf_mpc_override_config_t</a> nrf_mpc_override_config_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting configuration of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Structure with configuration of the override region. </dd></dl>

</div>
</div>
<a id="ga39c507026fa171618a79101c6233ca8b" name="ga39c507026fa171618a79101c6233ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39c507026fa171618a79101c6233ca8b">&#9670;&#160;</a></span>nrf_mpc_override_config_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_config_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__mpc__override__config__t.html">nrf_mpc_override_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting configuration of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure of the override region configuration parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac05d65c913a5fa0c53ea112257da7969" name="gac05d65c913a5fa0c53ea112257da7969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac05d65c913a5fa0c53ea112257da7969">&#9670;&#160;</a></span>nrf_mpc_override_endaddr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_override_endaddr_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting end address of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End address of the override region. </dd></dl>

</div>
</div>
<a id="ga3788c87dd9420235f8965883202c9c78" name="ga3788c87dd9420235f8965883202c9c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3788c87dd9420235f8965883202c9c78">&#9670;&#160;</a></span>nrf_mpc_override_endaddr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_endaddr_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting end address of the override region. </p>
<dl class="section note"><dt>Note</dt><dd>Address must be on a 4kB memory boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga398b9aad20b0735a4ada32812a3dd3d0" name="ga398b9aad20b0735a4ada32812a3dd3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga398b9aad20b0735a4ada32812a3dd3d0">&#9670;&#160;</a></span>nrf_mpc_override_masterport_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_override_masterport_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting enabled master ports of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of enabled master ports, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </dd></dl>

</div>
</div>
<a id="gae79fb68d0f2cdb8bab520731e25b38e9" name="gae79fb68d0f2cdb8bab520731e25b38e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae79fb68d0f2cdb8bab520731e25b38e9">&#9670;&#160;</a></span>nrf_mpc_override_masterport_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_masterport_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the specified master ports of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of master ports to be enabled, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebfa2cf1848130f9c4bc17c814545e1a" name="gaebfa2cf1848130f9c4bc17c814545e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebfa2cf1848130f9c4bc17c814545e1a">&#9670;&#160;</a></span>nrf_mpc_override_offset_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_override_offset_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting offset of the override region. </p>
<dl class="section note"><dt>Note</dt><dd>Offset is left shifted before applying, creating a 33-bit signed integer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address offset value divided by 2. </dd></dl>

</div>
</div>
<a id="ga4360714e10c9b3a46f342b9084b34911" name="ga4360714e10c9b3a46f342b9084b34911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4360714e10c9b3a46f342b9084b34911">&#9670;&#160;</a></span>nrf_mpc_override_offset_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_offset_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting offset of the override region. </p>
<dl class="section note"><dt>Note</dt><dd>Offset will be left shifted before applying, creating a 33-bit signed integer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Address offset value divided by 2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36bb427a4979cd656667b8a08ad55ff4" name="ga36bb427a4979cd656667b8a08ad55ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36bb427a4979cd656667b8a08ad55ff4">&#9670;&#160;</a></span>nrf_mpc_override_ownerid_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE nrf_owner_t nrf_mpc_override_ownerid_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting owner ID of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Owner ID of the overridde region. </dd></dl>

</div>
</div>
<a id="ga0fd600b1d367f88e6181ec42e9c1f842" name="ga0fd600b1d367f88e6181ec42e9c1f842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fd600b1d367f88e6181ec42e9c1f842">&#9670;&#160;</a></span>nrf_mpc_override_ownerid_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_ownerid_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nrf_owner_t&#160;</td>
          <td class="paramname"><em>owner_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting owner ID for the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">owner_id</td><td>Owner ID to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafced42e6003285cc6b93aef32c08715e" name="gafced42e6003285cc6b93aef32c08715e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafced42e6003285cc6b93aef32c08715e">&#9670;&#160;</a></span>nrf_mpc_override_perm_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_override_perm_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting permission settings of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of permissions, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga7647978ee34cb4523182c945f58551b9">nrf_mpc_permission_mask_t</a> enumerator values. </dd></dl>

</div>
</div>
<a id="ga765e067757c5e85d628788848163ee95" name="ga765e067757c5e85d628788848163ee95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga765e067757c5e85d628788848163ee95">&#9670;&#160;</a></span>nrf_mpc_override_perm_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_perm_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting permission settings for the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>Mask of permissions to be set, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga7647978ee34cb4523182c945f58551b9">nrf_mpc_permission_mask_t</a> enumerator values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga13a7fe4a399c7d24fcf9f9c7788c09c1" name="ga13a7fe4a399c7d24fcf9f9c7788c09c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13a7fe4a399c7d24fcf9f9c7788c09c1">&#9670;&#160;</a></span>nrf_mpc_override_permmask_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_override_permmask_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting permission settings mask of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of permissions settings mask, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga7647978ee34cb4523182c945f58551b9">nrf_mpc_permission_mask_t</a> enumerator values. </dd></dl>

</div>
</div>
<a id="ga9baa4d2ef6d04d3c6125f2ed9493aaf5" name="ga9baa4d2ef6d04d3c6125f2ed9493aaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9baa4d2ef6d04d3c6125f2ed9493aaf5">&#9670;&#160;</a></span>nrf_mpc_override_permmask_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_permmask_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting permission settings mask for the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>Mask of permissions settings mask to be set, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga7647978ee34cb4523182c945f58551b9">nrf_mpc_permission_mask_t</a> enumerator values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3d4c0b94e029e5c76125e12dee391cc" name="gae3d4c0b94e029e5c76125e12dee391cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3d4c0b94e029e5c76125e12dee391cc">&#9670;&#160;</a></span>nrf_mpc_override_startaddr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_override_startaddr_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting start address of the override region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Start address of the override region. </dd></dl>

</div>
</div>
<a id="ga860c13495b30810658e923daae9307c9" name="ga860c13495b30810658e923daae9307c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga860c13495b30810658e923daae9307c9">&#9670;&#160;</a></span>nrf_mpc_override_startaddr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_override_startaddr_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting start address of the override region. </p>
<dl class="section note"><dt>Note</dt><dd>Address must be on a 4kB memory boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Override region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5cffc828be3aca6ebdeac0461001f90" name="gae5cffc828be3aca6ebdeac0461001f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5cffc828be3aca6ebdeac0461001f90">&#9670;&#160;</a></span>nrf_mpc_region_addrmask_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_region_addrmask_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting address mask of the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address mask of the region. </dd></dl>

</div>
</div>
<a id="ga22f8d9a1f3e4fd561edbbdb88e143f6a" name="ga22f8d9a1f3e4fd561edbbdb88e143f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22f8d9a1f3e4fd561edbbdb88e143f6a">&#9670;&#160;</a></span>nrf_mpc_region_addrmask_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_region_addrmask_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting address mask of the region. </p>
<dl class="section note"><dt>Note</dt><dd>Mask must be on a 4kB memory boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab554feb151d3a8a84aa1ef49985b24b8" name="gab554feb151d3a8a84aa1ef49985b24b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab554feb151d3a8a84aa1ef49985b24b8">&#9670;&#160;</a></span>nrf_mpc_region_config_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE <a class="el" href="structnrf__mpc__region__config__t.html">nrf_mpc_region_config_t</a> nrf_mpc_region_config_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting configuration of the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Structure with configuration of the region. </dd></dl>

</div>
</div>
<a id="gacbff5f9ce331b63da982ea340f425c9a" name="gacbff5f9ce331b63da982ea340f425c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbff5f9ce331b63da982ea340f425c9a">&#9670;&#160;</a></span>nrf_mpc_region_config_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_region_config_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__mpc__region__config__t.html">nrf_mpc_region_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting configuration of the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure of the region configuration parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2ead7ef46873e85ffff2a217a3f1cd4" name="gaf2ead7ef46873e85ffff2a217a3f1cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2ead7ef46873e85ffff2a217a3f1cd4">&#9670;&#160;</a></span>nrf_mpc_region_masterport_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_region_masterport_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting enabled master ports of the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of enabled master ports, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </dd></dl>

</div>
</div>
<a id="ga447c3ac18526b96414f7222acf308d75" name="ga447c3ac18526b96414f7222acf308d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447c3ac18526b96414f7222acf308d75">&#9670;&#160;</a></span>nrf_mpc_region_masterport_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_region_masterport_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the specified master ports of the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of master ports to be enabled, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32f4b879381393d713cce3491fb1e57a" name="ga32f4b879381393d713cce3491fb1e57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32f4b879381393d713cce3491fb1e57a">&#9670;&#160;</a></span>nrf_mpc_region_startaddr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_region_startaddr_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting start address of the region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Start address of the region. </dd></dl>

</div>
</div>
<a id="ga7157d67ae0a98e234ee019202d106c40" name="ga7157d67ae0a98e234ee019202d106c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7157d67ae0a98e234ee019202d106c40">&#9670;&#160;</a></span>nrf_mpc_region_startaddr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_region_startaddr_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting start address of the region. </p>
<dl class="section note"><dt>Note</dt><dd>Address must be on a 4kB memory boundary.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Region index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga175f2577dab13295cdaec1156517ba2c" name="ga175f2577dab13295cdaec1156517ba2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga175f2577dab13295cdaec1156517ba2c">&#9670;&#160;</a></span>nrf_mpc_rtchoke_delay_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint8_t nrf_mpc_rtchoke_delay_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the Real Time Choke delay for the specified slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slave</td><td>Slave number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Delay value for slave. </dd></dl>

</div>
</div>
<a id="gad8417da63a1d979fbb0640f5863c4324" name="gad8417da63a1d979fbb0640f5863c4324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8417da63a1d979fbb0640f5863c4324">&#9670;&#160;</a></span>nrf_mpc_rtchoke_delay_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_rtchoke_delay_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting the Real Time Choke delay for the specified slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slave</td><td>Slave number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>Delay value to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e448fe5c32baa27c83d191623623249" name="ga5e448fe5c32baa27c83d191623623249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e448fe5c32baa27c83d191623623249">&#9670;&#160;</a></span>nrf_mpc_rtchoke_readaccess_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_rtchoke_readaccess_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting master ports with enabled AXI Read Address Channel Real Time Choke. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of master ports with the Read Real Time Choke enabled, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </dd></dl>

</div>
</div>
<a id="ga13bb38ea31028aae2aac0ee3e091b21e" name="ga13bb38ea31028aae2aac0ee3e091b21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13bb38ea31028aae2aac0ee3e091b21e">&#9670;&#160;</a></span>nrf_mpc_rtchoke_readaccess_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_rtchoke_readaccess_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the AXI Read Address Channel Real Time Choke for specified master ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of master ports to have the Read Real Time Choke enabled, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ddf36ab7898e4415c2a2334198598d5" name="ga2ddf36ab7898e4415c2a2334198598d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ddf36ab7898e4415c2a2334198598d5">&#9670;&#160;</a></span>nrf_mpc_rtchoke_writeaccess_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE uint32_t nrf_mpc_rtchoke_writeaccess_get </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type const *&#160;</td>
          <td class="paramname"><em>p_reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting master ports with enabled AXI Write Address Channel Real Time Choke. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of master ports with the Write Real Time Choke enabled, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </dd></dl>

</div>
</div>
<a id="gac611c03b4cabceedf8df9694361a6f66" name="gac611c03b4cabceedf8df9694361a6f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac611c03b4cabceedf8df9694361a6f66">&#9670;&#160;</a></span>nrf_mpc_rtchoke_writeaccess_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRF_STATIC_INLINE void nrf_mpc_rtchoke_writeaccess_set </td>
          <td>(</td>
          <td class="paramtype">NRF_MPC_Type *&#160;</td>
          <td class="paramname"><em>p_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the AXI Write Address Channel Real Time Choke for specified master ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_reg</td><td>Pointer to the structure of registers of the peripheral. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>Mask of master ports to have the Write Real Time Choke enabled, constructed from <a class="el" href="group__nrf__mpc__hal.html#ga89f734f107017134f3ff2c1136864626">nrf_mpc_masterport_mask_t</a> enumerator values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="https://github.com/NordicSemiconductor/nrfx/issues" target="_blank">nrfx feedback</a> | <a href="https://devzone.nordicsemi.com/" target="_blank">Nordic DevZone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Fri May 10 2024" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
</script>
</div>
</body>
</html>
