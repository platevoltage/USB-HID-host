<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>nrfx 3.5: PWM driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nrfx
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__nrfx__pwm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">PWM driver<div class="ingroups"><a class="el" href="group__nrfx__drivers.html">Drivers</a> &raquo; <a class="el" href="group__nrf__pwm.html">PWM</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Pulse Width Modulation (PWM) peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__nrfx__pwm__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm__config.html">PWM peripheral driver configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver instance data structure.  <a href="structnrfx__pwm__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver configuration structure.  <a href="structnrfx__pwm__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga248fea7bfb810bed3145b9927b7ab679"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga248fea7bfb810bed3145b9927b7ab679">NRFX_PWM_INSTANCE</a>(id)</td></tr>
<tr class="memdesc:ga248fea7bfb810bed3145b9927b7ab679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for creating a PWM driver instance.  <br /></td></tr>
<tr class="separator:ga248fea7bfb810bed3145b9927b7ab679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc78a6d1474cbf684932a84e06567321"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gabc78a6d1474cbf684932a84e06567321">NRFX_PWM_DEFAULT_CONFIG</a>(_out_0,  _out_1,  _out_2,  _out_3)</td></tr>
<tr class="memdesc:gabc78a6d1474cbf684932a84e06567321"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver default configuration.  <br /></td></tr>
<tr class="separator:gabc78a6d1474cbf684932a84e06567321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9c3de06e0f1a582c09fe9b78e4da121"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gae9c3de06e0f1a582c09fe9b78e4da121">NRFX_PWM_INST_HANDLER_GET</a>(idx)&#160;&#160;&#160;<a class="el" href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4">NRFX_CONCAT_3</a>(nrfx_pwm_, idx, _irq_handler)</td></tr>
<tr class="memdesc:gae9c3de06e0f1a582c09fe9b78e4da121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro returning PWM interrupt handler.  <br /></td></tr>
<tr class="separator:gae9c3de06e0f1a582c09fe9b78e4da121"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaba29a8fe00daca4a73976cc75a601274"><td class="memItemLeft" align="right" valign="top"><a id="gaba29a8fe00daca4a73976cc75a601274" name="gaba29a8fe00daca4a73976cc75a601274"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>nrfx_pwm_handler_t</b>) (<a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> event_type, void *p_context)</td></tr>
<tr class="memdesc:gaba29a8fe00daca4a73976cc75a601274"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event handler type. <br /></td></tr>
<tr class="separator:gaba29a8fe00daca4a73976cc75a601274"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a> = 0x01
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad">NRFX_PWM_FLAG_LOOP</a> = 0x02
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> = 0x04
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> = 0x08
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465">NRFX_PWM_FLAG_NO_EVT_FINISHED</a> = 0x10
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> = 0x80
<br />
 }</td></tr>
<tr class="memdesc:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM flags providing additional playback options.  <a href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">More...</a><br /></td></tr>
<tr class="separator:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd252a13f482085e89e23516b8a422a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f">NRFX_PWM_EVT_FINISHED</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a>
<br />
 }</td></tr>
<tr class="memdesc:ga3bd252a13f482085e89e23516b8a422a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event type.  <a href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">More...</a><br /></td></tr>
<tr class="separator:ga3bd252a13f482085e89e23516b8a422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga433c4fe4493b296fe7ac1d63f9af0cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga433c4fe4493b296fe7ac1d63f9af0cd0">nrfx_pwm_init</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *p_config, <a class="el" href="group__nrfx__pwm.html#gaba29a8fe00daca4a73976cc75a601274">nrfx_pwm_handler_t</a> handler, void *p_context)</td></tr>
<tr class="memdesc:ga433c4fe4493b296fe7ac1d63f9af0cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the PWM driver.  <br /></td></tr>
<tr class="separator:ga433c4fe4493b296fe7ac1d63f9af0cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9dbff06e53165a64ab350a12ba02cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga7d9dbff06e53165a64ab350a12ba02cd">nrfx_pwm_reconfigure</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *p_config)</td></tr>
<tr class="memdesc:ga7d9dbff06e53165a64ab350a12ba02cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reconfiguring the PWM driver.  <br /></td></tr>
<tr class="separator:ga7d9dbff06e53165a64ab350a12ba02cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ba03e5984116112721858d2cd6bec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gac6ba03e5984116112721858d2cd6bec6">nrfx_pwm_uninit</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gac6ba03e5984116112721858d2cd6bec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for uninitializing the PWM driver.  <br /></td></tr>
<tr class="separator:gac6ba03e5984116112721858d2cd6bec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05355c9c7b2295fb9409dc937bef522e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga05355c9c7b2295fb9409dc937bef522e">nrfx_pwm_init_check</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga05355c9c7b2295fb9409dc937bef522e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if the PWM driver instance is initialized.  <br /></td></tr>
<tr class="separator:ga05355c9c7b2295fb9409dc937bef522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15874083a69d6c88e827b3ccb51dec25"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga15874083a69d6c88e827b3ccb51dec25">nrfx_pwm_simple_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:ga15874083a69d6c88e827b3ccb51dec25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a single sequence playback.  <br /></td></tr>
<tr class="separator:ga15874083a69d6c88e827b3ccb51dec25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15573667e4fd472d77398ede40bb473"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gad15573667e4fd472d77398ede40bb473">nrfx_pwm_complex_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_0, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_1, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:gad15573667e4fd472d77398ede40bb473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a two-sequence playback.  <br /></td></tr>
<tr class="separator:gad15573667e4fd472d77398ede40bb473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfb5b014424ec8f6fda40f55da6ff1f6"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gacfb5b014424ec8f6fda40f55da6ff1f6">nrfx_pwm_step</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gacfb5b014424ec8f6fda40f55da6ff1f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for advancing the active sequence.  <br /></td></tr>
<tr class="separator:gacfb5b014424ec8f6fda40f55da6ff1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f47b9142d4ae40284cd8044be9ea35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gae7f47b9142d4ae40284cd8044be9ea35">nrfx_pwm_stop</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, bool wait_until_stopped)</td></tr>
<tr class="memdesc:gae7f47b9142d4ae40284cd8044be9ea35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for stopping the sequence playback.  <br /></td></tr>
<tr class="separator:gae7f47b9142d4ae40284cd8044be9ea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0d3fcf1f4eb1a2d2776a1272fb404b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga6f0d3fcf1f4eb1a2d2776a1272fb404b">nrfx_pwm_stopped_check</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga6f0d3fcf1f4eb1a2d2776a1272fb404b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking the status of the PWM peripheral.  <br /></td></tr>
<tr class="separator:ga6f0d3fcf1f4eb1a2d2776a1272fb404b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749917a72aaee584a76427021980098d"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga749917a72aaee584a76427021980098d">nrfx_pwm_sequence_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, uint8_t seq_id, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence)</td></tr>
<tr class="memdesc:ga749917a72aaee584a76427021980098d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the sequence data during playback.  <br /></td></tr>
<tr class="separator:ga749917a72aaee584a76427021980098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6355991cc62d20dff3e6d8c97af43b0"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gab6355991cc62d20dff3e6d8c97af43b0">nrfx_pwm_task_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a> task)</td></tr>
<tr class="memdesc:gab6355991cc62d20dff3e6d8c97af43b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM task that can be used in PPI module.  <br /></td></tr>
<tr class="separator:gab6355991cc62d20dff3e6d8c97af43b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga092229079f29535058054026a97501e9"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga092229079f29535058054026a97501e9">nrfx_pwm_event_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a> event)</td></tr>
<tr class="memdesc:ga092229079f29535058054026a97501e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM event that can be used in PPI module.  <br /></td></tr>
<tr class="separator:ga092229079f29535058054026a97501e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Pulse Width Modulation (PWM) peripheral driver. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gabc78a6d1474cbf684932a84e06567321" name="gabc78a6d1474cbf684932a84e06567321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc78a6d1474cbf684932a84e06567321">&#9670;&#160;</a></span>NRFX_PWM_DEFAULT_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_DEFAULT_CONFIG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_0, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_2, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_out_3&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                               \</div>
<div class="line">    .output_pins   = {                                          \</div>
<div class="line">        _out_0,                                                 \</div>
<div class="line">        _out_1,                                                 \</div>
<div class="line">        _out_2,                                                 \</div>
<div class="line">        _out_3,                                                 \</div>
<div class="line">    },                                                          \</div>
<div class="line">    .pin_inverted  = {                                          \</div>
<div class="line">        <span class="keyword">false</span>,                                                  \</div>
<div class="line">        <span class="keyword">false</span>,                                                  \</div>
<div class="line">        <span class="keyword">false</span>,                                                  \</div>
<div class="line">        <span class="keyword">false</span>,                                                  \</div>
<div class="line">    },                                                          \</div>
<div class="line">    .irq_priority  = <a class="code hl_define" href="group__nrfx__pwm__config.html#ga097ff5d073d1266dde45fbe2b0dbddc9">NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</a>,      \</div>
<div class="line">    .base_clock    = <a class="code hl_enumvalue" href="group__nrf__pwm__hal.html#gga8479da20e14394fb2388b1be3b879670a30e595429e6787e18df7ca04b897bb11">NRF_PWM_CLK_1MHz</a>,                          \</div>
<div class="line">    .count_mode    = <a class="code hl_enumvalue" href="group__nrf__pwm__hal.html#gga1f29b190ff13c52895d249e07ebe92cba0b9d394af2cbadb2fd430f73e6b2a28c">NRF_PWM_MODE_UP</a>,                           \</div>
<div class="line">    .top_value     = 1000,                                      \</div>
<div class="line">    .load_mode     = <a class="code hl_enumvalue" href="group__nrf__pwm__hal.html#gga453888e5feb46774da27499ca1eeafd2a23a17dad88a8dff161e09c5057e70362">NRF_PWM_LOAD_COMMON</a>,                       \</div>
<div class="line">    .step_mode     = <a class="code hl_enumvalue" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aec7f52e96da457170f1a516ea78357a1">NRF_PWM_STEP_AUTO</a>,                         \</div>
<div class="line">    .skip_gpio_cfg = <span class="keyword">false</span>                                      \</div>
<div class="line">}</div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_gga1f29b190ff13c52895d249e07ebe92cba0b9d394af2cbadb2fd430f73e6b2a28c"><div class="ttname"><a href="group__nrf__pwm__hal.html#gga1f29b190ff13c52895d249e07ebe92cba0b9d394af2cbadb2fd430f73e6b2a28c">NRF_PWM_MODE_UP</a></div><div class="ttdeci">@ NRF_PWM_MODE_UP</div><div class="ttdoc">Up counter (edge-aligned PWM duty cycle).</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:162</div></div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_gga453888e5feb46774da27499ca1eeafd2a23a17dad88a8dff161e09c5057e70362"><div class="ttname"><a href="group__nrf__pwm__hal.html#gga453888e5feb46774da27499ca1eeafd2a23a17dad88a8dff161e09c5057e70362">NRF_PWM_LOAD_COMMON</a></div><div class="ttdeci">@ NRF_PWM_LOAD_COMMON</div><div class="ttdoc">1st half word (16-bit) used in all PWM channels (0-3).</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:187</div></div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_gga8479da20e14394fb2388b1be3b879670a30e595429e6787e18df7ca04b897bb11"><div class="ttname"><a href="group__nrf__pwm__hal.html#gga8479da20e14394fb2388b1be3b879670a30e595429e6787e18df7ca04b897bb11">NRF_PWM_CLK_1MHz</a></div><div class="ttdeci">@ NRF_PWM_CLK_1MHz</div><div class="ttdoc">16 MHz / 16 = 1 MHz.</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:173</div></div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_ggae25a7e03c383934d33cda8a049b7dde4aec7f52e96da457170f1a516ea78357a1"><div class="ttname"><a href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aec7f52e96da457170f1a516ea78357a1">NRF_PWM_STEP_AUTO</a></div><div class="ttdeci">@ NRF_PWM_STEP_AUTO</div><div class="ttdoc">Automatically after the current value is played and repeated the requested number of times.</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:201</div></div>
<div class="ttc" id="agroup__nrfx__pwm__config_html_ga097ff5d073d1266dde45fbe2b0dbddc9"><div class="ttname"><a href="group__nrfx__pwm__config.html#ga097ff5d073d1266dde45fbe2b0dbddc9">NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</div><div class="ttdoc">Interrupt priority.</div><div class="ttdef"><b>Definition:</b> nrfx_pwm_dox_config.h:61</div></div>
</div><!-- fragment -->
<p>PWM driver default configuration. </p>
<p>This configuration sets up PWM with the following options:</p><ul>
<li>clock frequency: 1 MHz</li>
<li>count up</li>
<li>top value: 1000 clock ticks</li>
<li>load mode: common</li>
<li>step mode: auto</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_0</td><td>PWM output 0 pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_1</td><td>PWM output 1 pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_2</td><td>PWM output 2 pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_out_3</td><td>PWM output 3 pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9c3de06e0f1a582c09fe9b78e4da121" name="gae9c3de06e0f1a582c09fe9b78e4da121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9c3de06e0f1a582c09fe9b78e4da121">&#9670;&#160;</a></span>NRFX_PWM_INST_HANDLER_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_INST_HANDLER_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idx</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4">NRFX_CONCAT_3</a>(nrfx_pwm_, idx, _irq_handler)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro returning PWM interrupt handler. </p>
<p>param[in] idx PWM index.</p>
<dl class="section return"><dt>Returns</dt><dd>Interrupt handler. </dd></dl>

</div>
</div>
<a id="ga248fea7bfb810bed3145b9927b7ab679" name="ga248fea7bfb810bed3145b9927b7ab679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga248fea7bfb810bed3145b9927b7ab679">&#9670;&#160;</a></span>NRFX_PWM_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                          \</div>
<div class="line">    .p_reg       = <a class="code hl_define" href="group__nrfx__utils.html#ga5ea61d0994f6fb1ab5ed59d44f6a7ce9">NRFX_CONCAT</a>(NRF_, PWM, <span class="keywordtype">id</span>),             \</div>
<div class="line">    .instance_id = <a class="code hl_define" href="group__nrfx__utils.html#ga5ea61d0994f6fb1ab5ed59d44f6a7ce9">NRFX_CONCAT</a>(NRFX_PWM, <span class="keywordtype">id</span>, _INST_IDX),   \</div>
<div class="line">}</div>
<div class="ttc" id="agroup__nrfx__utils_html_ga5ea61d0994f6fb1ab5ed59d44f6a7ce9"><div class="ttname"><a href="group__nrfx__utils.html#ga5ea61d0994f6fb1ab5ed59d44f6a7ce9">NRFX_CONCAT</a></div><div class="ttdeci">#define NRFX_CONCAT(...)</div><div class="ttdoc">Macro for concatenating multiple arguments.</div><div class="ttdef"><b>Definition:</b> nrfx_utils.h:199</div></div>
</div><!-- fragment -->
<p>Macro for creating a PWM driver instance. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3bd252a13f482085e89e23516b8a422a" name="ga3bd252a13f482085e89e23516b8a422a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bd252a13f482085e89e23516b8a422a">&#9670;&#160;</a></span>nrfx_pwm_evt_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM driver event type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f" name="gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f"></a>NRFX_PWM_EVT_FINISHED&#160;</td><td class="fielddoc"><p>Sequence playback finished. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30" name="gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30"></a>NRFX_PWM_EVT_END_SEQ0&#160;</td><td class="fielddoc"><p>End of sequence 0 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957" name="gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957"></a>NRFX_PWM_EVT_END_SEQ1&#160;</td><td class="fielddoc"><p>End of sequence 1 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a" name="gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a"></a>NRFX_PWM_EVT_STOPPED&#160;</td><td class="fielddoc"><p>The PWM peripheral has been stopped. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga68ffb6414b8b5e07ddb4e14431b2bd1f" name="ga68ffb6414b8b5e07ddb4e14431b2bd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ffb6414b8b5e07ddb4e14431b2bd1f">&#9670;&#160;</a></span>nrfx_pwm_flag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM flags providing additional playback options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18" name="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18"></a>NRFX_PWM_FLAG_STOP&#160;</td><td class="fielddoc"><p>When the requested playback is finished, the peripheral will be stopped. </p><dl class="section note"><dt>Note</dt><dd>The STOP task is triggered when the last value of the final sequence is loaded from RAM, and the peripheral stops at the end of the current PWM period. For sequences with configured repeating of duty cycle values, this might result in less than the requested number of repeats of the last value. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad" name="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad"></a>NRFX_PWM_FLAG_LOOP&#160;</td><td class="fielddoc"><p>When the requested playback is finished, it will be started from the beginning. This flag is ignored if used together with <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a>. </p><dl class="section note"><dt>Note</dt><dd>The playback restart is done via a shortcut configured in the PWM peripheral. This shortcut triggers the proper starting task when the final value of previous playback is read from RAM and applied to the pulse generator counter. When this mechanism is used together with the <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode, the playback restart will occur right after switching to the final value (this final value will be played only once). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213" name="gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ0&#160;</td><td class="fielddoc"><p>The event handler is to be called when the last value from sequence 0 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa" name="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ1&#160;</td><td class="fielddoc"><p>The event handler is to be called when the last value from sequence 1 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465" name="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465"></a>NRFX_PWM_FLAG_NO_EVT_FINISHED&#160;</td><td class="fielddoc"><p>The playback finished event (enabled by default) is to be suppressed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec" name="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec"></a>NRFX_PWM_FLAG_START_VIA_TASK&#160;</td><td class="fielddoc"><p>The playback must not be started directly by the called function. Instead, the function must only prepare it and return the address of the task to be triggered to start the playback. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad15573667e4fd472d77398ede40bb473" name="gad15573667e4fd472d77398ede40bb473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad15573667e4fd472d77398ede40bb473">&#9670;&#160;</a></span>nrfx_pwm_complex_playback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_complex_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a two-sequence playback. </p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (using PPI for instance). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on the stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_0</td><td>First sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_1</td><td>Second sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga092229079f29535058054026a97501e9" name="ga092229079f29535058054026a97501e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga092229079f29535058054026a97501e9">&#9670;&#160;</a></span>nrfx_pwm_event_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE uint32_t nrfx_pwm_event_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM event that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Requested event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event address. </dd></dl>

</div>
</div>
<a id="ga433c4fe4493b296fe7ac1d63f9af0cd0" name="ga433c4fe4493b296fe7ac1d63f9af0cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga433c4fe4493b296fe7ac1d63f9af0cd0">&#9670;&#160;</a></span>nrfx_pwm_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_pwm_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrfx__pwm.html#gaba29a8fe00daca4a73976cc75a601274">nrfx_pwm_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the PWM driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure with the initial configuration. NULL if configuration is to be skipped and will be done later using <a class="el" href="group__nrfx__pwm.html#ga7d9dbff06e53165a64ab350a12ba02cd">nrfx_pwm_reconfigure</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Event handler provided by the user. If NULL is passed instead, event notifications are not done and PWM interrupts are disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>Context passed to the event handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_ALREADY</td><td>The driver is already initialized. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>The driver is already initialized. Deprecated - use <a class="el" href="group__nrfx__error__codes.html#gga2449720f8fa17b22243218068459a24badc3fc33e8a7dc8b9a9547fe07b437efd">NRFX_ERROR_ALREADY</a> instead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga05355c9c7b2295fb9409dc937bef522e" name="ga05355c9c7b2295fb9409dc937bef522e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05355c9c7b2295fb9409dc937bef522e">&#9670;&#160;</a></span>nrfx_pwm_init_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_init_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if the PWM driver instance is initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Instance is already initialized. </td></tr>
    <tr><td class="paramname">false</td><td>Instance is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d9dbff06e53165a64ab350a12ba02cd" name="ga7d9dbff06e53165a64ab350a12ba02cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d9dbff06e53165a64ab350a12ba02cd">&#9670;&#160;</a></span>nrfx_pwm_reconfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_pwm_reconfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reconfiguring the PWM driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure with the configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Reconfiguration was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>The driver is during playback. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>The driver is uninitialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga749917a72aaee584a76427021980098d" name="ga749917a72aaee584a76427021980098d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga749917a72aaee584a76427021980098d">&#9670;&#160;</a></span>nrfx_pwm_sequence_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_sequence_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the sequence data during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Pointer to the new sequence definition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15874083a69d6c88e827b3ccb51dec25" name="ga15874083a69d6c88e827b3ccb51dec25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15874083a69d6c88e827b3ccb51dec25">&#9670;&#160;</a></span>nrfx_pwm_simple_playback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_simple_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a single sequence playback. </p>
<p>To take advantage of the looping mechanism in the PWM peripheral, both sequences must be used (single sequence can be played back only once by the peripheral). Therefore, the provided sequence is internally set and played back as both sequence 0 and sequence 1. Consequently, if the end of sequence notifications are required, events for both sequences must be used (that is, both the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> flag and the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> flag must be specified, and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a> event and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a> event must be handled in the same way).</p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (for example, by using PPI). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on the stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a id="gacfb5b014424ec8f6fda40f55da6ff1f6" name="gacfb5b014424ec8f6fda40f55da6ff1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfb5b014424ec8f6fda40f55da6ff1f6">&#9670;&#160;</a></span>nrfx_pwm_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_pwm_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for advancing the active sequence. </p>
<p>This function only applies to <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7f47b9142d4ae40284cd8044be9ea35" name="gae7f47b9142d4ae40284cd8044be9ea35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7f47b9142d4ae40284cd8044be9ea35">&#9670;&#160;</a></span>nrfx_pwm_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_stopped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for stopping the sequence playback. </p>
<p>The playback is stopped at the end of the current PWM period. This means that if the active sequence is configured to repeat each duty cycle value for a certain number of PWM periods, the last played value might appear on the output less times than requested.</p>
<dl class="section note"><dt>Note</dt><dd>This function can be instructed to wait until the playback is stopped (by setting <code>wait_until_stopped</code> to true). Depending on the length of the PMW period, this might take a significant amount of time. Alternatively, the <a class="el" href="group__nrfx__pwm.html#ga6f0d3fcf1f4eb1a2d2776a1272fb404b">nrfx_pwm_stopped_check</a> function can be used to poll the status, or the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a> event can be used to get the notification when the playback is stopped, provided the event handler is defined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_until_stopped</td><td>If true, the function will not return until the playback is stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>The PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f0d3fcf1f4eb1a2d2776a1272fb404b" name="ga6f0d3fcf1f4eb1a2d2776a1272fb404b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f0d3fcf1f4eb1a2d2776a1272fb404b">&#9670;&#160;</a></span>nrfx_pwm_stopped_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_stopped_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking the status of the PWM peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>The PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6355991cc62d20dff3e6d8c97af43b0" name="gab6355991cc62d20dff3e6d8c97af43b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6355991cc62d20dff3e6d8c97af43b0">&#9670;&#160;</a></span>nrfx_pwm_task_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE uint32_t nrfx_pwm_task_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM task that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Requested task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task address. </dd></dl>

</div>
</div>
<a id="gac6ba03e5984116112721858d2cd6bec6" name="gac6ba03e5984116112721858d2cd6bec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6ba03e5984116112721858d2cd6bec6">&#9670;&#160;</a></span>nrfx_pwm_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for uninitializing the PWM driver. </p>
<p>If any sequence playback is in progress, it is stopped immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="https://github.com/NordicSemiconductor/nrfx/issues" target="_blank">nrfx feedback</a> | <a href="https://devzone.nordicsemi.com/" target="_blank">Nordic DevZone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Fri May 10 2024" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
</script>
</div>
</body>
</html>
