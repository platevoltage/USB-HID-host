<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>nrfx 3.5: UARTE driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nrfx
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__nrfx__uarte.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">UARTE driver<div class="ingroups"><a class="el" href="group__nrfx__drivers.html">Drivers</a> &raquo; <a class="el" href="group__nrf__uarte.html">UARTE</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>UARTE peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__nrfx__uarte__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte__config.html">UARTE peripheral driver configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___n_r_f_x___u_a_r_t_e___r_x___e_n_a_b_l_e___f_l_a_g_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f_x___u_a_r_t_e___r_x___e_n_a_b_l_e___f_l_a_g_s.html">Flags used for @ref nrfx_uarte_rx_enable.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___n_r_f_x___u_a_r_t_e___t_x___f_l_a_g_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f_x___u_a_r_t_e___t_x___f_l_a_g_s.html">Flags used for @ref nrfx_uarte_tx.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___n_r_f_x___u_a_r_t_e___t_x___d_o_n_e___f_l_a_g_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f_x___u_a_r_t_e___t_x___d_o_n_e___f_l_a_g_s.html">Flags used for @ref nrfx_uarte_tx_evt_t.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the UARTE driver instance.  <a href="structnrfx__uarte__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__rx__cache__t.html">nrfx_uarte_rx_cache_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used internally to handle reception through cache buffers.  <a href="structnrfx__uarte__rx__cache__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__config__t.html">nrfx_uarte_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the UARTE configuration.  <a href="structnrfx__uarte__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__rx__evt__t.html">nrfx_uarte_rx_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a611da59f7c1ac9071506a5a6ec63f240">NRFX_UARTE_EVT_RX_DONE</a> event.  <a href="structnrfx__uarte__rx__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__tx__evt__t.html">nrfx_uarte_tx_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a45e67c5ce7924b80c49c65ed142191b8">NRFX_UARTE_EVT_TX_DONE</a> event.  <a href="structnrfx__uarte__tx__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__error__evt__t.html">nrfx_uarte_error_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a2fb5fbdaa0163d8be3957c49ea5b17d3">NRFX_UARTE_EVT_ERROR</a>.  <a href="structnrfx__uarte__error__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__rx__disabled__evt__t.html">nrfx_uarte_rx_disabled_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a4742d2486f4a9955b927669be87e0a78">NRFX_UARTE_EVT_RX_DISABLED</a>.  <a href="structnrfx__uarte__rx__disabled__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__uarte__event__t.html">nrfx_uarte_event_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for UARTE event.  <a href="structnrfx__uarte__event__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae703f44b0377aff75ae0b53c38488ffb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gae703f44b0377aff75ae0b53c38488ffb">NRFX_UARTE_INSTANCE</a>(id)</td></tr>
<tr class="memdesc:gae703f44b0377aff75ae0b53c38488ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for creating a UARTE driver instance.  <br /></td></tr>
<tr class="separator:gae703f44b0377aff75ae0b53c38488ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707a68ab1d952435a3e372d59c93262f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga707a68ab1d952435a3e372d59c93262f">NRFX_UARTE_DEFAULT_CONFIG</a>(_pin_tx,  _pin_rx)</td></tr>
<tr class="memdesc:ga707a68ab1d952435a3e372d59c93262f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UARTE driver default configuration.  <br /></td></tr>
<tr class="separator:ga707a68ab1d952435a3e372d59c93262f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e19db933b507f33418e827f28867191"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga0e19db933b507f33418e827f28867191">NRFX_UARTE_INST_HANDLER_GET</a>(idx)&#160;&#160;&#160;<a class="el" href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4">NRFX_CONCAT_3</a>(nrfx_uarte_, idx, _irq_handler)</td></tr>
<tr class="memdesc:ga0e19db933b507f33418e827f28867191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro returning UARTE interrupt handler.  <br /></td></tr>
<tr class="separator:ga0e19db933b507f33418e827f28867191"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga82d5e19e10c37084a54b102871c15731"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga82d5e19e10c37084a54b102871c15731">nrfx_uarte_event_handler_t</a>) (<a class="el" href="structnrfx__uarte__event__t.html">nrfx_uarte_event_t</a> const *p_event, void *p_context)</td></tr>
<tr class="memdesc:ga82d5e19e10c37084a54b102871c15731"><td class="mdescLeft">&#160;</td><td class="mdescRight">UARTE interrupt event handler.  <br /></td></tr>
<tr class="separator:ga82d5e19e10c37084a54b102871c15731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga11a91e3594938e682dc90b8d2efaa762"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga11a91e3594938e682dc90b8d2efaa762">nrfx_uarte_evt_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a45e67c5ce7924b80c49c65ed142191b8">NRFX_UARTE_EVT_TX_DONE</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a611da59f7c1ac9071506a5a6ec63f240">NRFX_UARTE_EVT_RX_DONE</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a2fb5fbdaa0163d8be3957c49ea5b17d3">NRFX_UARTE_EVT_ERROR</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762ab8129f86b0848abf0ba7431798010b68">NRFX_UARTE_EVT_RX_BUF_REQUEST</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a4742d2486f4a9955b927669be87e0a78">NRFX_UARTE_EVT_RX_DISABLED</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762aaaa23762f18f22a0f534cf4912b2da1d">NRFX_UARTE_EVT_RX_BUF_TOO_LATE</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95">NRFX_UARTE_EVT_RX_BYTE</a>
, <br />
&#160;&#160;<a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762aae7ac2a90cf9bc065e6ece2766675dff">NRFX_UARTE_EVT_TRIGGER</a>
<br />
 }</td></tr>
<tr class="memdesc:ga11a91e3594938e682dc90b8d2efaa762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of UARTE driver events.  <a href="group__nrfx__uarte.html#ga11a91e3594938e682dc90b8d2efaa762">More...</a><br /></td></tr>
<tr class="separator:ga11a91e3594938e682dc90b8d2efaa762"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab4d3196116ca4553cf67390be5814052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gab4d3196116ca4553cf67390be5814052">nrfx_uarte_init</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, <a class="el" href="structnrfx__uarte__config__t.html">nrfx_uarte_config_t</a> const *p_config, <a class="el" href="group__nrfx__uarte.html#ga82d5e19e10c37084a54b102871c15731">nrfx_uarte_event_handler_t</a> event_handler)</td></tr>
<tr class="memdesc:gab4d3196116ca4553cf67390be5814052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the UARTE driver.  <br /></td></tr>
<tr class="separator:gab4d3196116ca4553cf67390be5814052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39141e1fcab086cfb096e3a5fd220f83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga39141e1fcab086cfb096e3a5fd220f83">nrfx_uarte_reconfigure</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, <a class="el" href="structnrfx__uarte__config__t.html">nrfx_uarte_config_t</a> const *p_config)</td></tr>
<tr class="memdesc:ga39141e1fcab086cfb096e3a5fd220f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reconfiguring the UARTE driver.  <br /></td></tr>
<tr class="separator:ga39141e1fcab086cfb096e3a5fd220f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa31a9d9e52bfa9196f0dd13bb574eb4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gaa31a9d9e52bfa9196f0dd13bb574eb4d">nrfx_uarte_uninit</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gaa31a9d9e52bfa9196f0dd13bb574eb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for uninitializing the UARTE driver.  <br /></td></tr>
<tr class="separator:gaa31a9d9e52bfa9196f0dd13bb574eb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db0cdc31de6692a60e2edea7e3e15d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga0db0cdc31de6692a60e2edea7e3e15d3">nrfx_uarte_init_check</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga0db0cdc31de6692a60e2edea7e3e15d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if the UARTE driver instance is initialized.  <br /></td></tr>
<tr class="separator:ga0db0cdc31de6692a60e2edea7e3e15d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fff2a3784029ba3bfb596428d1bc698"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga5fff2a3784029ba3bfb596428d1bc698">nrfx_uarte_task_address_get</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, <a class="el" href="group__nrf__uarte__hal.html#gae99a63cb1416b51c2e2282c4c56a6b12">nrf_uarte_task_t</a> task)</td></tr>
<tr class="memdesc:ga5fff2a3784029ba3bfb596428d1bc698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the address of the specified UARTE task.  <br /></td></tr>
<tr class="separator:ga5fff2a3784029ba3bfb596428d1bc698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3318e17ee8dc0e700acf91be6b2c6c0a"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga3318e17ee8dc0e700acf91be6b2c6c0a">nrfx_uarte_event_address_get</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, <a class="el" href="group__nrf__uarte__hal.html#ga1189b14604f6051467bc91b337c45d6a">nrf_uarte_event_t</a> event)</td></tr>
<tr class="memdesc:ga3318e17ee8dc0e700acf91be6b2c6c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the address of the specified UARTE event.  <br /></td></tr>
<tr class="separator:ga3318e17ee8dc0e700acf91be6b2c6c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b292e16625db4d43372101d14cc7a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga0b292e16625db4d43372101d14cc7a62">nrfx_uarte_tx</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, uint8_t const *p_data, size_t length, uint32_t flags)</td></tr>
<tr class="memdesc:ga0b292e16625db4d43372101d14cc7a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for sending data over UARTE.  <br /></td></tr>
<tr class="separator:ga0b292e16625db4d43372101d14cc7a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa581a3dd85162dc91d287458d19df656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gaa581a3dd85162dc91d287458d19df656">nrfx_uarte_tx_in_progress</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gaa581a3dd85162dc91d287458d19df656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if UARTE is currently transmitting.  <br /></td></tr>
<tr class="separator:gaa581a3dd85162dc91d287458d19df656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576b4e16f016e6a06149e89c1bb72d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga576b4e16f016e6a06149e89c1bb72d16">nrfx_uarte_tx_abort</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, bool sync)</td></tr>
<tr class="memdesc:ga576b4e16f016e6a06149e89c1bb72d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for aborting any ongoing transmission.  <br /></td></tr>
<tr class="separator:ga576b4e16f016e6a06149e89c1bb72d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c4adc4f62622df1d6c4f4d16160976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gad9c4adc4f62622df1d6c4f4d16160976">nrfx_uarte_rx_enable</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, uint32_t flags)</td></tr>
<tr class="memdesc:gad9c4adc4f62622df1d6c4f4d16160976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the receiver.  <br /></td></tr>
<tr class="separator:gad9c4adc4f62622df1d6c4f4d16160976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad807914470b77a67b387692cbe110133"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gad807914470b77a67b387692cbe110133">nrfx_uarte_rx_buffer_set</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, uint8_t *p_data, size_t length)</td></tr>
<tr class="memdesc:gad807914470b77a67b387692cbe110133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for providing reception buffer.  <br /></td></tr>
<tr class="separator:gad807914470b77a67b387692cbe110133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e605ee5a6e23572d958b3971a4faaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga1e605ee5a6e23572d958b3971a4faaf5">nrfx_uarte_rx</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, uint8_t *p_data, size_t length)</td></tr>
<tr class="memdesc:ga1e605ee5a6e23572d958b3971a4faaf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for receiving data over UARTE.  <br /></td></tr>
<tr class="separator:ga1e605ee5a6e23572d958b3971a4faaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf898b4e1e3f58477c9c427524449f448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gaf898b4e1e3f58477c9c427524449f448">nrfx_uarte_rx_ready</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, size_t *p_rx_amount)</td></tr>
<tr class="memdesc:gaf898b4e1e3f58477c9c427524449f448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for testing the receiver state in blocking mode.  <br /></td></tr>
<tr class="separator:gaf898b4e1e3f58477c9c427524449f448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74fe76caea2d085ac247ebf456d4553a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga74fe76caea2d085ac247ebf456d4553a">nrfx_uarte_rx_abort</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance, bool disable_all, bool sync)</td></tr>
<tr class="memdesc:ga74fe76caea2d085ac247ebf456d4553a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for aborting any ongoing reception.  <br /></td></tr>
<tr class="separator:ga74fe76caea2d085ac247ebf456d4553a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5738c62ee62b5d8c46193f268410185"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gaf5738c62ee62b5d8c46193f268410185">nrfx_uarte_errorsrc_get</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gaf5738c62ee62b5d8c46193f268410185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading error source mask.  <br /></td></tr>
<tr class="separator:gaf5738c62ee62b5d8c46193f268410185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4d454ab63a92188be22ded0ad5241b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gaef4d454ab63a92188be22ded0ad5241b">nrfx_uarte_rx_new_data_check</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gaef4d454ab63a92188be22ded0ad5241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if there was new RX data since the last check.  <br /></td></tr>
<tr class="separator:gaef4d454ab63a92188be22ded0ad5241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa41a1b20f41894a8fab1380f7e532cb9"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gaa41a1b20f41894a8fab1380f7e532cb9">nrfx_uarte_rxdrdy_enable</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gaa41a1b20f41894a8fab1380f7e532cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95">NRFX_UARTE_EVT_RX_BYTE</a> event.  <br /></td></tr>
<tr class="separator:gaa41a1b20f41894a8fab1380f7e532cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76092d25f48dda7671bfaf426545367"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#gaf76092d25f48dda7671bfaf426545367">nrfx_uarte_rxdrdy_disable</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gaf76092d25f48dda7671bfaf426545367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95">NRFX_UARTE_EVT_RX_BYTE</a> event.  <br /></td></tr>
<tr class="separator:gaf76092d25f48dda7671bfaf426545367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c7ebbe367bba4f5aaaabd765cfdebd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__uarte.html#ga8c7ebbe367bba4f5aaaabd765cfdebd4">nrfx_uarte_int_trigger</a> (<a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga8c7ebbe367bba4f5aaaabd765cfdebd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for triggering UARTE interrupt.  <br /></td></tr>
<tr class="separator:ga8c7ebbe367bba4f5aaaabd765cfdebd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UARTE peripheral driver. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga707a68ab1d952435a3e372d59c93262f" name="ga707a68ab1d952435a3e372d59c93262f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga707a68ab1d952435a3e372d59c93262f">&#9670;&#160;</a></span>NRFX_UARTE_DEFAULT_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_UARTE_DEFAULT_CONFIG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_pin_tx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_pin_rx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UARTE driver default configuration. </p>
<p>This configuration sets up UARTE with the following options:</p><ul>
<li>hardware flow control disabled</li>
<li>no parity bit</li>
<li>one stop bit</li>
<li>baudrate: 115200</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_pin_tx</td><td>TX pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_pin_rx</td><td>RX pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e19db933b507f33418e827f28867191" name="ga0e19db933b507f33418e827f28867191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e19db933b507f33418e827f28867191">&#9670;&#160;</a></span>NRFX_UARTE_INST_HANDLER_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_UARTE_INST_HANDLER_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idx</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4">NRFX_CONCAT_3</a>(nrfx_uarte_, idx, _irq_handler)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro returning UARTE interrupt handler. </p>
<p>param[in] idx UARTE index.</p>
<dl class="section return"><dt>Returns</dt><dd>Interrupt handler. </dd></dl>

</div>
</div>
<a id="gae703f44b0377aff75ae0b53c38488ffb" name="gae703f44b0377aff75ae0b53c38488ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae703f44b0377aff75ae0b53c38488ffb">&#9670;&#160;</a></span>NRFX_UARTE_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_UARTE_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                             \</div>
<div class="line">    .p_reg        = <a class="code hl_define" href="group__nrfx__utils.html#ga5ea61d0994f6fb1ab5ed59d44f6a7ce9">NRFX_CONCAT</a>(NRF_, UARTE, <span class="keywordtype">id</span>),             \</div>
<div class="line">    .drv_inst_idx = <a class="code hl_define" href="group__nrfx__utils.html#ga5ea61d0994f6fb1ab5ed59d44f6a7ce9">NRFX_CONCAT</a>(NRFX_UARTE, <span class="keywordtype">id</span>, _INST_IDX),   \</div>
<div class="line">}</div>
<div class="ttc" id="agroup__nrfx__utils_html_ga5ea61d0994f6fb1ab5ed59d44f6a7ce9"><div class="ttname"><a href="group__nrfx__utils.html#ga5ea61d0994f6fb1ab5ed59d44f6a7ce9">NRFX_CONCAT</a></div><div class="ttdeci">#define NRFX_CONCAT(...)</div><div class="ttdoc">Macro for concatenating multiple arguments.</div><div class="ttdef"><b>Definition:</b> nrfx_utils.h:199</div></div>
</div><!-- fragment -->
<p>Macro for creating a UARTE driver instance. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga82d5e19e10c37084a54b102871c15731" name="ga82d5e19e10c37084a54b102871c15731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82d5e19e10c37084a54b102871c15731">&#9670;&#160;</a></span>nrfx_uarte_event_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nrfx_uarte_event_handler_t) (<a class="el" href="structnrfx__uarte__event__t.html">nrfx_uarte_event_t</a> const *p_event, void *p_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UARTE interrupt event handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Pointer to event structure. Event is allocated on the stack so it is available only within the context of the event handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>Context passed to the interrupt handler, set on initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga11a91e3594938e682dc90b8d2efaa762" name="ga11a91e3594938e682dc90b8d2efaa762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11a91e3594938e682dc90b8d2efaa762">&#9670;&#160;</a></span>nrfx_uarte_evt_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__uarte.html#ga11a91e3594938e682dc90b8d2efaa762">nrfx_uarte_evt_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of UARTE driver events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762a45e67c5ce7924b80c49c65ed142191b8" name="gga11a91e3594938e682dc90b8d2efaa762a45e67c5ce7924b80c49c65ed142191b8"></a>NRFX_UARTE_EVT_TX_DONE&#160;</td><td class="fielddoc"><p>Requested TX transfer completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762a611da59f7c1ac9071506a5a6ec63f240" name="gga11a91e3594938e682dc90b8d2efaa762a611da59f7c1ac9071506a5a6ec63f240"></a>NRFX_UARTE_EVT_RX_DONE&#160;</td><td class="fielddoc"><p>Requested RX transfer completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762a2fb5fbdaa0163d8be3957c49ea5b17d3" name="gga11a91e3594938e682dc90b8d2efaa762a2fb5fbdaa0163d8be3957c49ea5b17d3"></a>NRFX_UARTE_EVT_ERROR&#160;</td><td class="fielddoc"><p>Error reported by UART peripheral. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762ab8129f86b0848abf0ba7431798010b68" name="gga11a91e3594938e682dc90b8d2efaa762ab8129f86b0848abf0ba7431798010b68"></a>NRFX_UARTE_EVT_RX_BUF_REQUEST&#160;</td><td class="fielddoc"><p>Request for a RX buffer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762a4742d2486f4a9955b927669be87e0a78" name="gga11a91e3594938e682dc90b8d2efaa762a4742d2486f4a9955b927669be87e0a78"></a>NRFX_UARTE_EVT_RX_DISABLED&#160;</td><td class="fielddoc"><p>Receiver is disabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762aaaa23762f18f22a0f534cf4912b2da1d" name="gga11a91e3594938e682dc90b8d2efaa762aaaa23762f18f22a0f534cf4912b2da1d"></a>NRFX_UARTE_EVT_RX_BUF_TOO_LATE&#160;</td><td class="fielddoc"><p>RX buffer request handled too late. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95" name="gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95"></a>NRFX_UARTE_EVT_RX_BYTE&#160;</td><td class="fielddoc"><p>Byte was received. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga11a91e3594938e682dc90b8d2efaa762aae7ac2a90cf9bc065e6ece2766675dff" name="gga11a91e3594938e682dc90b8d2efaa762aae7ac2a90cf9bc065e6ece2766675dff"></a>NRFX_UARTE_EVT_TRIGGER&#160;</td><td class="fielddoc"><p>Result of <a class="el" href="group__nrfx__uarte.html#ga8c7ebbe367bba4f5aaaabd765cfdebd4">nrfx_uarte_int_trigger</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf5738c62ee62b5d8c46193f268410185" name="gaf5738c62ee62b5d8c46193f268410185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5738c62ee62b5d8c46193f268410185">&#9670;&#160;</a></span>nrfx_uarte_errorsrc_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_uarte_errorsrc_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading error source mask. </p>
<p>Mask contains values from <a class="el" href="group__nrf__uarte__hal.html#ga83eec8b883f6b2e77e4baa39b65d9cb0">nrf_uarte_error_mask_t</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Function must be used in the blocking mode only. In case of non-blocking mode, an error event is generated. Function clears error sources after reading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Mask of reported errors. </dd></dl>

</div>
</div>
<a id="ga3318e17ee8dc0e700acf91be6b2c6c0a" name="ga3318e17ee8dc0e700acf91be6b2c6c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3318e17ee8dc0e700acf91be6b2c6c0a">&#9670;&#160;</a></span>nrfx_uarte_event_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE uint32_t nrfx_uarte_event_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__uarte__hal.html#ga1189b14604f6051467bc91b337c45d6a">nrf_uarte_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the address of the specified UARTE event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event address. </dd></dl>

</div>
</div>
<a id="gab4d3196116ca4553cf67390be5814052" name="gab4d3196116ca4553cf67390be5814052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4d3196116ca4553cf67390be5814052">&#9670;&#160;</a></span>nrfx_uarte_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__config__t.html">nrfx_uarte_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrfx__uarte.html#ga82d5e19e10c37084a54b102871c15731">nrfx_uarte_event_handler_t</a>&#160;</td>
          <td class="paramname"><em>event_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the UARTE driver. </p>
<p>This function configures UARTE but peripheral is kept disabled to reduce power consumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure with the initial configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_handler</td><td>Event handler provided by the user. If not provided driver works in blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_ALREADY</td><td>The driver is already initialized. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>The driver is already initialized. Deprecated - use <a class="el" href="group__nrfx__error__codes.html#gga2449720f8fa17b22243218068459a24badc3fc33e8a7dc8b9a9547fe07b437efd">NRFX_ERROR_ALREADY</a> instead. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_PARAM</td><td>Invalid configuration. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>Some other peripheral with the same instance ID is already in use. This is possible only if <a class="el" href="group__nrfx__prs.html">Peripheral Resource Sharing (PRS)</a> module is enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0db0cdc31de6692a60e2edea7e3e15d3" name="ga0db0cdc31de6692a60e2edea7e3e15d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db0cdc31de6692a60e2edea7e3e15d3">&#9670;&#160;</a></span>nrfx_uarte_init_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_uarte_init_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if the UARTE driver instance is initialized. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Instance is already initialized. </td></tr>
    <tr><td class="paramname">false</td><td>Instance is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c7ebbe367bba4f5aaaabd765cfdebd4" name="ga8c7ebbe367bba4f5aaaabd765cfdebd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c7ebbe367bba4f5aaaabd765cfdebd4">&#9670;&#160;</a></span>nrfx_uarte_int_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_int_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for triggering UARTE interrupt. </p>
<p>Function can be used to jump into UARTE interrupt context. User handler is called with the event <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762aae7ac2a90cf9bc065e6ece2766675dff">NRFX_UARTE_EVT_TRIGGER</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_ERROR_FORBIDDEN</td><td>Failure. User handler is not configured. </td></tr>
    <tr><td class="paramname">NRFX_SUCCESS</td><td>If interrupt is successfully triggered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39141e1fcab086cfb096e3a5fd220f83" name="ga39141e1fcab086cfb096e3a5fd220f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39141e1fcab086cfb096e3a5fd220f83">&#9670;&#160;</a></span>nrfx_uarte_reconfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_reconfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__config__t.html">nrfx_uarte_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reconfiguring the UARTE driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure with the configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Reconfiguration was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>The driver is during transfer. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>The driver is uninitialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e605ee5a6e23572d958b3971a4faaf5" name="ga1e605ee5a6e23572d958b3971a4faaf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e605ee5a6e23572d958b3971a4faaf5">&#9670;&#160;</a></span>nrfx_uarte_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for receiving data over UARTE. </p>
<p>If an event handler is provided in the <a class="el" href="group__nrfx__uarte.html#gab4d3196116ca4553cf67390be5814052" title="Function for initializing the UARTE driver.">nrfx_uarte_init()</a> call, this function returns immediately and the handler is called when the transfer is done. Otherwise, the transfer is performed in blocking mode, that is this function returns when the transfer is finished. Blocking mode is not using interrupt so there is no context switching inside the function. The receive buffer pointer is double-buffered in non-blocking mode. The secondary buffer can be set immediately after starting the transfer and will be filled when the primary buffer is full. The double-buffering feature allows receiving data continuously.</p>
<dl class="section note"><dt>Note</dt><dd>Peripherals using EasyDMA (including UARTE) require the transfer buffers to be placed in the Data RAM region. If this condition is not met, this function fails with the error code NRFX_ERROR_INVALID_ADDR.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When the double-buffering feature is used and the UARTE interrupt is processed with a delay (for example, due to a higher priority interrupt) long enough for both buffers to get filled completely, the event handler will be invoked only once, to notify that the first buffer has been filled. This is because from hardware perspective it is impossible to deduce in such case if the second buffer was also filled completely or not. To prevent this from happening, keep the UARTE interrupt latency low or use large enough reception buffers.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a class="el" href="group__nrfx__uarte.html#gad9c4adc4f62622df1d6c4f4d16160976">nrfx_uarte_rx_enable</a> and <a class="el" href="group__nrfx__uarte.html#gad807914470b77a67b387692cbe110133">nrfx_uarte_rx_buffer_set</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_data</td><td>Pointer to data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to receive. Maximum possible length is dependent on the used SoC (see the MAXCNT register description in the Product Specification). The driver checks it with assertion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Initialization is successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>The driver is already receiving (and the secondary buffer has already been set in non-blocking mode). </td></tr>
    <tr><td class="paramname">NRFX_ERROR_FORBIDDEN</td><td>The transfer is aborted from a different context (blocking mode only). </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INTERNAL</td><td>The UARTE peripheral reports an error. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_ADDR</td><td>p_data does not point to RAM buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74fe76caea2d085ac247ebf456d4553a" name="ga74fe76caea2d085ac247ebf456d4553a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74fe76caea2d085ac247ebf456d4553a">&#9670;&#160;</a></span>nrfx_uarte_rx_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_rx_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disable_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for aborting any ongoing reception. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a611da59f7c1ac9071506a5a6ec63f240">NRFX_UARTE_EVT_RX_DONE</a> event will be generated in non-blocking mode. It will contain number of bytes received until the abort was called. The event handler will be called from the UARTE interrupt context.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>When the double-buffering feature is used and the UARTE interrupt is processed with a delay (for example, due to a higher priority interrupt) long enough for the first buffer to be filled completely, the event handler will be supplied with the pointer to the first buffer and the number of bytes received in the second buffer. This is because from hardware perspective it is impossible to deduce the reception of which buffer has been aborted. To prevent this from happening, keep the UARTE interrupt latency low or use large enough reception buffers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">disable_all</td><td>If true, UARTE is stopped. If false and there is a second RX buffer provided, only the first transfer is stopped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>If true, receiver is disabled synchronously.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Successfully initiate disabling or disabled (synchronous mode). </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>Receiver was not enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad807914470b77a67b387692cbe110133" name="gad807914470b77a67b387692cbe110133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad807914470b77a67b387692cbe110133">&#9670;&#160;</a></span>nrfx_uarte_rx_buffer_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_rx_buffer_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for providing reception buffer. </p>
<p>The function should be called as a response to the <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762ab8129f86b0848abf0ba7431798010b68">NRFX_UARTE_EVT_RX_BUF_REQUEST</a> event. If the function is called before enabling the receiver, the first buffer is configured. If the function is called and there is no active buffer but the receiver is enabled but not started, it starts reception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_data</td><td>Pointer to a buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Buffer successfully set. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>Buffer provided without pending request. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_TIMEOUT</td><td>Buffer provided too late. Receiver is being disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9c4adc4f62622df1d6c4f4d16160976" name="gad9c4adc4f62622df1d6c4f4d16160976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c4adc4f62622df1d6c4f4d16160976">&#9670;&#160;</a></span>nrfx_uarte_rx_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_rx_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the receiver. </p>
<p>The event handler will be called from the caller context with the <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762ab8129f86b0848abf0ba7431798010b68">NRFX_UARTE_EVT_RX_BUF_REQUEST</a> event. The user may respond and provide a buffer using <a class="el" href="group__nrfx__uarte.html#gad807914470b77a67b387692cbe110133">nrfx_uarte_rx_buffer_set</a>. An error is returned if buffer is not provided. After that, the receiver is started and another <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762ab8129f86b0848abf0ba7431798010b68">NRFX_UARTE_EVT_RX_BUF_REQUEST</a> is generated. If a new buffer is not provided, then the receiver is disabled once the first buffer becomes full. If a new buffer is provided, then the receiver will seamlessly switch to a new buffer (using a hardware shortcut).</p>
<dl class="section note"><dt>Note</dt><dd>If transmitter is inactive then peripheral is disabled after receiver is stopped to achieve the lowest power consumption.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Option flags. See <a class="el" href="group___n_r_f_x___u_a_r_t_e___r_x___e_n_a_b_l_e___f_l_a_g_s.html">Flags used for <a class="el" href="group__nrfx__uarte.html#gad9c4adc4f62622df1d6c4f4d16160976">nrfx_uarte_rx_enable</a>.</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Receiver successfully enabled. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>When receiver is already enabled. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_NO_MEM</td><td>When buffer was not provided. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef4d454ab63a92188be22ded0ad5241b" name="gaef4d454ab63a92188be22ded0ad5241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4d454ab63a92188be22ded0ad5241b">&#9670;&#160;</a></span>nrfx_uarte_rx_new_data_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_uarte_rx_new_data_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if there was new RX data since the last check. </p>
<p>Function checks <a class="el" href="group__nrf__uarte__hal.html#gga1189b14604f6051467bc91b337c45d6aad82cb8f90030dfd0a66ac658a29722ec">NRF_UARTE_EVENT_RXDRDY</a> event and clears it if it was set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>At least one byte was received since the last check. </td></tr>
    <tr><td class="paramname">false</td><td>No new data was received since the last check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf898b4e1e3f58477c9c427524449f448" name="gaf898b4e1e3f58477c9c427524449f448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf898b4e1e3f58477c9c427524449f448">&#9670;&#160;</a></span>nrfx_uarte_rx_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_rx_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_rx_amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for testing the receiver state in blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_rx_amount</td><td>Pointer to the variable to be filled with the number of received bytes. Can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>The receiving operation is completed. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>The receiver did not complete the operation. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_FORBIDDEN</td><td>Operation is not supporting in the current configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf76092d25f48dda7671bfaf426545367" name="gaf76092d25f48dda7671bfaf426545367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf76092d25f48dda7671bfaf426545367">&#9670;&#160;</a></span>nrfx_uarte_rxdrdy_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_uarte_rxdrdy_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95">NRFX_UARTE_EVT_RX_BYTE</a> event. </p>
<p>The function disables the RXDRDY hardware event. See the <a class="el" href="group__nrfx__uarte.html#gaa41a1b20f41894a8fab1380f7e532cb9">nrfx_uarte_rxdrdy_enable</a> for more details. The event can be disabled at any time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa41a1b20f41894a8fab1380f7e532cb9" name="gaa41a1b20f41894a8fab1380f7e532cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa41a1b20f41894a8fab1380f7e532cb9">&#9670;&#160;</a></span>nrfx_uarte_rxdrdy_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_uarte_rxdrdy_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95">NRFX_UARTE_EVT_RX_BYTE</a> event. </p>
<p>The function enables the <a class="el" href="group__nrf__uarte__hal.html#gga1189b14604f6051467bc91b337c45d6aad82cb8f90030dfd0a66ac658a29722ec">NRF_UARTE_EVENT_RXDRDY</a> hardware event which is generated whenever a byte is received in RXD registers. The event indicates only that data is received, hence it must not be used yet because it may not be present yet in the RAM buffer handled by the EasyDMA. The event can be used only to detect a receiver activity. The event can be enabled at any time. Enabling it may increase the number of interrupts (after each received byte).</p>
<dl class="section note"><dt>Note</dt><dd>If there were a receiver activity prior to enabling the <a class="el" href="group__nrf__uarte__hal.html#gga1189b14604f6051467bc91b337c45d6aad82cb8f90030dfd0a66ac658a29722ec">NRF_UARTE_EVENT_RXDRDY</a> event, the <a class="el" href="group__nrf__uarte__hal.html#gga1189b14604f6051467bc91b337c45d6aad82cb8f90030dfd0a66ac658a29722ec">NRF_UARTE_EVENT_RXDRDY</a> event may already be set and the <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a0a868bf956cab8e6abdd6f982d5c2a95">NRFX_UARTE_EVT_RX_BYTE</a> will be triggered immediately. To avoid that, it is recommended to clear that event by calling the <a class="el" href="group__nrfx__uarte.html#gaef4d454ab63a92188be22ded0ad5241b">nrfx_uarte_rx_new_data_check</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fff2a3784029ba3bfb596428d1bc698" name="ga5fff2a3784029ba3bfb596428d1bc698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fff2a3784029ba3bfb596428d1bc698">&#9670;&#160;</a></span>nrfx_uarte_task_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE uint32_t nrfx_uarte_task_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__uarte__hal.html#gae99a63cb1416b51c2e2282c4c56a6b12">nrf_uarte_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the address of the specified UARTE task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task address. </dd></dl>

</div>
</div>
<a id="ga0b292e16625db4d43372101d14cc7a62" name="ga0b292e16625db4d43372101d14cc7a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b292e16625db4d43372101d14cc7a62">&#9670;&#160;</a></span>nrfx_uarte_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for sending data over UARTE. </p>
<p>If an event handler is provided in <a class="el" href="group__nrfx__uarte.html#gab4d3196116ca4553cf67390be5814052" title="Function for initializing the UARTE driver.">nrfx_uarte_init()</a> call, this function returns immediately (unless special flags are used) and the handler is called when the transfer is done. Otherwise, the transfer is performed in blocking mode, that is, this function returns when the transfer is finished.</p>
<dl class="section note"><dt>Note</dt><dd>Peripherals using EasyDMA (including UARTE) require the transfer buffers to be placed in the Data RAM region. If this condition is not met, this function will attempt to use the cache buffer provided in the configuration and if it is not available it will return error.</dd>
<dd>
To achieve the lowest power consumption, transmitter is stopped and peripheral is disabled (if receiver is not used) when transfer is completed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_data</td><td>Pointer to data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to send. Maximum possible length is dependent on the used SoC (see the MAXCNT register description in the Product Specification). The driver checks it with assertion. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Option flags. See <a class="el" href="group___n_r_f_x___u_a_r_t_e___t_x___f_l_a_g_s.html">Flags used for <a class="el" href="group__nrfx__uarte.html#ga0b292e16625db4d43372101d14cc7a62">nrfx_uarte_tx</a>.</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>Driver is busy transferring the data. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_FORBIDDEN</td><td>The transfer was aborted from a different context (blocking mode only) or transfer cannot be performed due to driver state, configuration or transfer parameters. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_ADDR</td><td>p_data does not point to RAM buffer and cache buffer is not provided or attempted to use non DMA buffer with linked transfer (see <a class="el" href="group___n_r_f_x___u_a_r_t_e___t_x___f_l_a_g_s.html#ga030575ba323f8d432e6d070d0af96774">NRFX_UARTE_TX_LINK</a>). </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_LENGTH</td><td>Flag <a class="el" href="group___n_r_f_x___u_a_r_t_e___t_x___f_l_a_g_s.html#gab185df30fa5d41904ab380ee4158db81">NRFX_UARTE_TX_EARLY_RETURN</a> is used but <code>length</code> exceeds internal buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga576b4e16f016e6a06149e89c1bb72d16" name="ga576b4e16f016e6a06149e89c1bb72d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga576b4e16f016e6a06149e89c1bb72d16">&#9670;&#160;</a></span>nrfx_uarte_tx_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_uarte_tx_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for aborting any ongoing transmission. </p>
<dl class="section note"><dt>Note</dt><dd>When abortion is not synchronous, the <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a45e67c5ce7924b80c49c65ed142191b8">NRFX_UARTE_EVT_TX_DONE</a> event will be generated in non-blocking mode. It will contain the number of bytes sent until the abort was called. If <a class="el" href="group___n_r_f_x___u_a_r_t_e___t_x___f_l_a_g_s.html#ga030575ba323f8d432e6d070d0af96774">NRFX_UARTE_TX_LINK</a> flag was used for the transfer and linked transfer have not started yet, there will be the second <a class="el" href="group__nrfx__uarte.html#gga11a91e3594938e682dc90b8d2efaa762a45e67c5ce7924b80c49c65ed142191b8">NRFX_UARTE_EVT_TX_DONE</a> event with length equal to 0. The event handler will be called from the UARTE interrupt context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>If true operation is synchronous. Transmitter is stopped upon function return and no event is generated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Successfully initiated abort or when transmitter synchronously stopped. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>Attempt to asynchronously abort when no transfer is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa581a3dd85162dc91d287458d19df656" name="gaa581a3dd85162dc91d287458d19df656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa581a3dd85162dc91d287458d19df656">&#9670;&#160;</a></span>nrfx_uarte_tx_in_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_uarte_tx_in_progress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if UARTE is currently transmitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The UARTE is transmitting. </td></tr>
    <tr><td class="paramname">false</td><td>The UARTE is not transmitting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa31a9d9e52bfa9196f0dd13bb574eb4d" name="gaa31a9d9e52bfa9196f0dd13bb574eb4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa31a9d9e52bfa9196f0dd13bb574eb4d">&#9670;&#160;</a></span>nrfx_uarte_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_uarte_uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__uarte__t.html">nrfx_uarte_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for uninitializing the UARTE driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="https://github.com/NordicSemiconductor/nrfx/issues" target="_blank">nrfx feedback</a> | <a href="https://devzone.nordicsemi.com/" target="_blank">Nordic DevZone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Fri May 10 2024" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
</script>
</div>
</body>
</html>
