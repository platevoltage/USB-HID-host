<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<title>nrfx 3.5: NVMC driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nrfx
   &#160;<span id="projectnumber">3.5</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__nrfx__nvmc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">NVMC driver<div class="ingroups"><a class="el" href="group__nrfx__drivers.html">Drivers</a> &raquo; <a class="el" href="group__nrf__nvmc.html">NVMC</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Non-Volatile Memory Controller (NVMC) peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf0b15ac7398c3037b88b59c7fcaff20a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#gaf0b15ac7398c3037b88b59c7fcaff20a">nrfx_nvmc_page_erase</a> (uint32_t address)</td></tr>
<tr class="memdesc:gaf0b15ac7398c3037b88b59c7fcaff20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for erasing a page in flash.  <br /></td></tr>
<tr class="separator:gaf0b15ac7398c3037b88b59c7fcaff20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1136f3454f77fab08ba94f94a373b538"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga1136f3454f77fab08ba94f94a373b538">nrfx_nvmc_uicr_erase</a> (void)</td></tr>
<tr class="memdesc:ga1136f3454f77fab08ba94f94a373b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for erasing the user information configuration register (UICR).  <br /></td></tr>
<tr class="separator:ga1136f3454f77fab08ba94f94a373b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85781588ba14021ded786b7e8f92d053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga85781588ba14021ded786b7e8f92d053">nrfx_nvmc_all_erase</a> (void)</td></tr>
<tr class="memdesc:ga85781588ba14021ded786b7e8f92d053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for erasing the whole flash memory.  <br /></td></tr>
<tr class="separator:ga85781588ba14021ded786b7e8f92d053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b9e9163e3dd703ea32ace243297368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#gac9b9e9163e3dd703ea32ace243297368">nrfx_nvmc_page_partial_erase_init</a> (uint32_t address, uint32_t duration_ms)</td></tr>
<tr class="memdesc:gac9b9e9163e3dd703ea32ace243297368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initiating a complete page erase split into parts (also known as partial erase).  <br /></td></tr>
<tr class="separator:gac9b9e9163e3dd703ea32ace243297368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga056243905d1a6e78c3b8e1ffd0886779"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga056243905d1a6e78c3b8e1ffd0886779">nrfx_nvmc_page_partial_erase_continue</a> (void)</td></tr>
<tr class="memdesc:ga056243905d1a6e78c3b8e1ffd0886779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for performing a part of the complete page erase (also known as partial erase).  <br /></td></tr>
<tr class="separator:ga056243905d1a6e78c3b8e1ffd0886779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73e6af0bfda875da0e0b76859077f9d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga73e6af0bfda875da0e0b76859077f9d4">nrfx_nvmc_byte_writable_check</a> (uint32_t address, uint8_t value)</td></tr>
<tr class="memdesc:ga73e6af0bfda875da0e0b76859077f9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking whether a byte is writable at the specified address.  <br /></td></tr>
<tr class="separator:ga73e6af0bfda875da0e0b76859077f9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399000fb5977151de6adf7b08503b60d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga399000fb5977151de6adf7b08503b60d">nrfx_nvmc_byte_write</a> (uint32_t address, uint8_t value)</td></tr>
<tr class="memdesc:ga399000fb5977151de6adf7b08503b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing a single byte to flash.  <br /></td></tr>
<tr class="separator:ga399000fb5977151de6adf7b08503b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fedba8a52edf87f03a0d3de865ccc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga92fedba8a52edf87f03a0d3de865ccc9">nrfx_nvmc_halfword_writable_check</a> (uint32_t address, uint16_t value)</td></tr>
<tr class="memdesc:ga92fedba8a52edf87f03a0d3de865ccc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking whether a halfword is writable at the specified address.  <br /></td></tr>
<tr class="separator:ga92fedba8a52edf87f03a0d3de865ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66dfc2e3d6e3940ef12477c2eaab5cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga66dfc2e3d6e3940ef12477c2eaab5cdb">nrfx_nvmc_halfword_write</a> (uint32_t address, uint16_t value)</td></tr>
<tr class="memdesc:ga66dfc2e3d6e3940ef12477c2eaab5cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing a 16-bit halfword to flash.  <br /></td></tr>
<tr class="separator:ga66dfc2e3d6e3940ef12477c2eaab5cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8cd173377bc4d1ae943b9eedc0074f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga9a8cd173377bc4d1ae943b9eedc0074f">nrfx_nvmc_word_writable_check</a> (uint32_t address, uint32_t value)</td></tr>
<tr class="memdesc:ga9a8cd173377bc4d1ae943b9eedc0074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking whether a word is writable at the specified address.  <br /></td></tr>
<tr class="separator:ga9a8cd173377bc4d1ae943b9eedc0074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61cfb10bcc72814ebf0dc04629fc4bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga61cfb10bcc72814ebf0dc04629fc4bcf">nrfx_nvmc_word_write</a> (uint32_t address, uint32_t value)</td></tr>
<tr class="memdesc:ga61cfb10bcc72814ebf0dc04629fc4bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing a 32-bit word to flash.  <br /></td></tr>
<tr class="separator:ga61cfb10bcc72814ebf0dc04629fc4bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57b135322719272be99c514b2f360661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga57b135322719272be99c514b2f360661">nrfx_nvmc_bytes_write</a> (uint32_t address, void const *src, uint32_t num_bytes)</td></tr>
<tr class="memdesc:ga57b135322719272be99c514b2f360661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing consecutive bytes to flash.  <br /></td></tr>
<tr class="separator:ga57b135322719272be99c514b2f360661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcbab6bdac9f16a8b2eab8be0698c4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#gabdcbab6bdac9f16a8b2eab8be0698c4f">nrfx_nvmc_words_write</a> (uint32_t address, void const *src, uint32_t num_words)</td></tr>
<tr class="memdesc:gabdcbab6bdac9f16a8b2eab8be0698c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing consecutive words to flash.  <br /></td></tr>
<tr class="separator:gabdcbab6bdac9f16a8b2eab8be0698c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12bc6d38b813eaa6c3e33d8681b15529"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga12bc6d38b813eaa6c3e33d8681b15529">nrfx_nvmc_otp_halfword_read</a> (uint32_t address)</td></tr>
<tr class="memdesc:ga12bc6d38b813eaa6c3e33d8681b15529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading a 16-bit aligned halfword from the OTP (UICR)  <br /></td></tr>
<tr class="separator:ga12bc6d38b813eaa6c3e33d8681b15529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d6fd4feefe96f3939b887c799fb60f"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga67d6fd4feefe96f3939b887c799fb60f">nrfx_nvmc_uicr_word_read</a> (uint32_t const volatile *address)</td></tr>
<tr class="memdesc:ga67d6fd4feefe96f3939b887c799fb60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading a 32-bit aligned word from the UICR.  <br /></td></tr>
<tr class="separator:ga67d6fd4feefe96f3939b887c799fb60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a35eb43e624e84293fd0187d947fdab"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga7a35eb43e624e84293fd0187d947fdab">nrfx_nvmc_flash_size_get</a> (void)</td></tr>
<tr class="memdesc:ga7a35eb43e624e84293fd0187d947fdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the total flash size in bytes.  <br /></td></tr>
<tr class="separator:ga7a35eb43e624e84293fd0187d947fdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618b9b451de6267d6614baae41fa090f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga618b9b451de6267d6614baae41fa090f">nrfx_nvmc_flash_page_size_get</a> (void)</td></tr>
<tr class="memdesc:ga618b9b451de6267d6614baae41fa090f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the flash page size in bytes.  <br /></td></tr>
<tr class="separator:ga618b9b451de6267d6614baae41fa090f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0bbf5041b542a66726bb97ad571cc4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga7b0bbf5041b542a66726bb97ad571cc4">nrfx_nvmc_flash_page_count_get</a> (void)</td></tr>
<tr class="memdesc:ga7b0bbf5041b542a66726bb97ad571cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the flash page count.  <br /></td></tr>
<tr class="separator:ga7b0bbf5041b542a66726bb97ad571cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadefedd962852c5c685c1da242858171c"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#gadefedd962852c5c685c1da242858171c">nrfx_nvmc_write_done_check</a> (void)</td></tr>
<tr class="memdesc:gadefedd962852c5c685c1da242858171c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if the last flash write has been completed.  <br /></td></tr>
<tr class="separator:gadefedd962852c5c685c1da242858171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36eb097ee20de05cfed37f2518bd911d"><td class="memItemLeft" align="right" valign="top">NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__nvmc.html#ga36eb097ee20de05cfed37f2518bd911d">nrfx_nvmc_icache_enable</a> (void)</td></tr>
<tr class="memdesc:ga36eb097ee20de05cfed37f2518bd911d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the Instruction Cache (ICache).  <br /></td></tr>
<tr class="separator:ga36eb097ee20de05cfed37f2518bd911d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a174aaa70c57116e5c19a43d8f4aa3"><td class="memItemLeft" align="right" valign="top"><a id="ga55a174aaa70c57116e5c19a43d8f4aa3" name="ga55a174aaa70c57116e5c19a43d8f4aa3"></a>
NRFX_STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>nrfx_nvmc_icache_disable</b> (void)</td></tr>
<tr class="memdesc:ga55a174aaa70c57116e5c19a43d8f4aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling ICache. <br /></td></tr>
<tr class="separator:ga55a174aaa70c57116e5c19a43d8f4aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Non-Volatile Memory Controller (NVMC) peripheral driver. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga85781588ba14021ded786b7e8f92d053" name="ga85781588ba14021ded786b7e8f92d053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85781588ba14021ded786b7e8f92d053">&#9670;&#160;</a></span>nrfx_nvmc_all_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_nvmc_all_erase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for erasing the whole flash memory. </p>
<dl class="section note"><dt>Note</dt><dd>All user code and UICR will be erased. </dd></dl>

</div>
</div>
<a id="ga73e6af0bfda875da0e0b76859077f9d4" name="ga73e6af0bfda875da0e0b76859077f9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73e6af0bfda875da0e0b76859077f9d4">&#9670;&#160;</a></span>nrfx_nvmc_byte_writable_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_nvmc_byte_writable_check </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking whether a byte is writable at the specified address. </p>
<p>The NVMC is only able to write '0' to bits in the flash that are erased (set to '1'). It cannot rewrite a bit back to '1'. This function checks if the value currently residing at the specified address can be transformed to the desired value without any '0' to '1' transitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to be checked. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Byte can be written at the specified address. </td></tr>
    <tr><td class="paramname">false</td><td>Byte cannot be written at the specified address. Erase the page or change the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga399000fb5977151de6adf7b08503b60d" name="ga399000fb5977151de6adf7b08503b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399000fb5977151de6adf7b08503b60d">&#9670;&#160;</a></span>nrfx_nvmc_byte_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_nvmc_byte_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing a single byte to flash. </p>
<p>To determine if the flash write has been completed, use <a class="el" href="group__nrfx__nvmc.html#gadefedd962852c5c685c1da242858171c">nrfx_nvmc_write_done_check()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to write to. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga57b135322719272be99c514b2f360661" name="ga57b135322719272be99c514b2f360661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57b135322719272be99c514b2f360661">&#9670;&#160;</a></span>nrfx_nvmc_bytes_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_nvmc_bytes_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing consecutive bytes to flash. </p>
<p>To determine if the last flash write has been completed, use <a class="el" href="group__nrfx__nvmc.html#gadefedd962852c5c685c1da242858171c">nrfx_nvmc_write_done_check()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to write to. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to the data to copy from. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b0bbf5041b542a66726bb97ad571cc4" name="ga7b0bbf5041b542a66726bb97ad571cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0bbf5041b542a66726bb97ad571cc4">&#9670;&#160;</a></span>nrfx_nvmc_flash_page_count_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_nvmc_flash_page_count_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the flash page count. </p>
<dl class="section return"><dt>Returns</dt><dd>Flash page count. </dd></dl>

</div>
</div>
<a id="ga618b9b451de6267d6614baae41fa090f" name="ga618b9b451de6267d6614baae41fa090f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga618b9b451de6267d6614baae41fa090f">&#9670;&#160;</a></span>nrfx_nvmc_flash_page_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_nvmc_flash_page_size_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the flash page size in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Flash page size in bytes. </dd></dl>

</div>
</div>
<a id="ga7a35eb43e624e84293fd0187d947fdab" name="ga7a35eb43e624e84293fd0187d947fdab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a35eb43e624e84293fd0187d947fdab">&#9670;&#160;</a></span>nrfx_nvmc_flash_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_nvmc_flash_size_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the total flash size in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Flash total size in bytes. </dd></dl>

</div>
</div>
<a id="ga92fedba8a52edf87f03a0d3de865ccc9" name="ga92fedba8a52edf87f03a0d3de865ccc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92fedba8a52edf87f03a0d3de865ccc9">&#9670;&#160;</a></span>nrfx_nvmc_halfword_writable_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_nvmc_halfword_writable_check </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking whether a halfword is writable at the specified address. </p>
<p>The NVMC is only able to write '0' to bits in the Flash that are erased (set to '1'). It cannot rewrite a bit back to '1'. This function checks if the value currently residing at the specified address can be transformed to the desired value without any '0' to '1' transitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to be checked. Must be halfword-aligned. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Halfword can be written at the specified address. </td></tr>
    <tr><td class="paramname">false</td><td>Halfword cannot be written at the specified address. Erase page or change address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga66dfc2e3d6e3940ef12477c2eaab5cdb" name="ga66dfc2e3d6e3940ef12477c2eaab5cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66dfc2e3d6e3940ef12477c2eaab5cdb">&#9670;&#160;</a></span>nrfx_nvmc_halfword_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_nvmc_halfword_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing a 16-bit halfword to flash. </p>
<p>To determine if the flash write has been completed, use <a class="el" href="group__nrfx__nvmc.html#gadefedd962852c5c685c1da242858171c">nrfx_nvmc_write_done_check()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to write to. Must be halfword-aligned. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36eb097ee20de05cfed37f2518bd911d" name="ga36eb097ee20de05cfed37f2518bd911d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36eb097ee20de05cfed37f2518bd911d">&#9670;&#160;</a></span>nrfx_nvmc_icache_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE void nrfx_nvmc_icache_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the Instruction Cache (ICache). </p>
<p>Enabling ICache reduces the amount of accesses to flash memory, which can boost performance and lower power consumption. </p>

</div>
</div>
<a id="ga12bc6d38b813eaa6c3e33d8681b15529" name="ga12bc6d38b813eaa6c3e33d8681b15529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12bc6d38b813eaa6c3e33d8681b15529">&#9670;&#160;</a></span>nrfx_nvmc_otp_halfword_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t nrfx_nvmc_otp_halfword_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading a 16-bit aligned halfword from the OTP (UICR) </p>
<p>OTP is a region of the UICR present in some chips. This function must be used to read halfword data from this region since unaligned accesses are not available on the OTP flash area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to read from. Must be halfword-aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>contents at <code>address</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0b15ac7398c3037b88b59c7fcaff20a" name="gaf0b15ac7398c3037b88b59c7fcaff20a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0b15ac7398c3037b88b59c7fcaff20a">&#9670;&#160;</a></span>nrfx_nvmc_page_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_nvmc_page_erase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for erasing a page in flash. </p>
<p>This function blocks until the erase operation finishes.</p>
<dl class="section note"><dt>Note</dt><dd>Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address of the first word in the page to erase.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Page erase complete. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_ADDR</td><td>Address is not aligned to the size of the page. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga056243905d1a6e78c3b8e1ffd0886779" name="ga056243905d1a6e78c3b8e1ffd0886779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga056243905d1a6e78c3b8e1ffd0886779">&#9670;&#160;</a></span>nrfx_nvmc_page_partial_erase_continue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_nvmc_page_partial_erase_continue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for performing a part of the complete page erase (also known as partial erase). </p>
<p>This function must be called several times to erase the whole page, once for each erase part.</p>
<dl class="section note"><dt>Note</dt><dd>The actual time needed to perform each part of the page erase is longer than the partial erase duration specified in the call to <a class="el" href="group__nrfx__nvmc.html#gac9b9e9163e3dd703ea32ace243297368">nrfx_nvmc_page_partial_erase_init</a>, since the NVMC peripheral needs certain additional amount of time to handle the process. For details regarding this additional time, see the "Electrical specification" section for the NVMC peripheral in the Product Specification.</dd>
<dd>
Using a page that was not completely erased leads to undefined behavior. Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Partial erase finished. </td></tr>
    <tr><td class="paramname">false</td><td>Partial erase not finished. Call the function again to process the next part. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac9b9e9163e3dd703ea32ace243297368" name="gac9b9e9163e3dd703ea32ace243297368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b9e9163e3dd703ea32ace243297368">&#9670;&#160;</a></span>nrfx_nvmc_page_partial_erase_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_nvmc_page_partial_erase_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>duration_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initiating a complete page erase split into parts (also known as partial erase). </p>
<p>This function initiates a partial erase with the specified duration. To execute each part of the partial erase, use <a class="el" href="group__nrfx__nvmc.html#ga056243905d1a6e78c3b8e1ffd0886779">nrfx_nvmc_page_partial_erase_continue</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address of the first word in the page to erase. </td></tr>
    <tr><td class="paramname">duration_ms</td><td>Time in milliseconds that each partial erase will take.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Partial erase started. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_ADDR</td><td>Address is not aligned to the size of the page.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrfx__nvmc.html#ga056243905d1a6e78c3b8e1ffd0886779" title="Function for performing a part of the complete page erase (also known as partial erase).">nrfx_nvmc_page_partial_erase_continue()</a> </dd></dl>

</div>
</div>
<a id="ga1136f3454f77fab08ba94f94a373b538" name="ga1136f3454f77fab08ba94f94a373b538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1136f3454f77fab08ba94f94a373b538">&#9670;&#160;</a></span>nrfx_nvmc_uicr_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_nvmc_uicr_erase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for erasing the user information configuration register (UICR). </p>
<dl class="section note"><dt>Note</dt><dd>Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>UICR has been successfully erased. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_NOT_SUPPORTED</td><td>UICR erase is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga67d6fd4feefe96f3939b887c799fb60f" name="ga67d6fd4feefe96f3939b887c799fb60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d6fd4feefe96f3939b887c799fb60f">&#9670;&#160;</a></span>nrfx_nvmc_uicr_word_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE uint32_t nrfx_nvmc_uicr_word_read </td>
          <td>(</td>
          <td class="paramtype">uint32_t const volatile *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading a 32-bit aligned word from the UICR. </p>
<p>This function should be used to read from the UICR since reading the flash main memory area straight after reading the UICR results in undefined behaviour for nRF9160.</p>
<dl class="section note"><dt>Note</dt><dd>See anomaly 7 in the errata document.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to read from. Must be word-aligned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>contents at <code>address</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a8cd173377bc4d1ae943b9eedc0074f" name="ga9a8cd173377bc4d1ae943b9eedc0074f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a8cd173377bc4d1ae943b9eedc0074f">&#9670;&#160;</a></span>nrfx_nvmc_word_writable_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_nvmc_word_writable_check </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking whether a word is writable at the specified address. </p>
<p>The NVMC is only able to write '0' to bits in the Flash that are erased (set to '1'). It cannot rewrite a bit back to '1'. This function checks if the value currently residing at the specified address can be transformed to the desired value without any '0' to '1' transitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to be checked. Must be word-aligned. </td></tr>
    <tr><td class="paramname">value</td><td>Value to be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Word can be written at the specified address. </td></tr>
    <tr><td class="paramname">false</td><td>Word cannot be written at the specified address. Erase page or change address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61cfb10bcc72814ebf0dc04629fc4bcf" name="ga61cfb10bcc72814ebf0dc04629fc4bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61cfb10bcc72814ebf0dc04629fc4bcf">&#9670;&#160;</a></span>nrfx_nvmc_word_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_nvmc_word_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing a 32-bit word to flash. </p>
<p>To determine if the flash write has been completed, use <a class="el" href="group__nrfx__nvmc.html#gadefedd962852c5c685c1da242858171c">nrfx_nvmc_write_done_check()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to write to. Must be word-aligned. </td></tr>
    <tr><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabdcbab6bdac9f16a8b2eab8be0698c4f" name="gabdcbab6bdac9f16a8b2eab8be0698c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabdcbab6bdac9f16a8b2eab8be0698c4f">&#9670;&#160;</a></span>nrfx_nvmc_words_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_nvmc_words_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing consecutive words to flash. </p>
<p>To determine if the last flash write has been completed, use <a class="el" href="group__nrfx__nvmc.html#gadefedd962852c5c685c1da242858171c">nrfx_nvmc_write_done_check()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Depending on the source of the code being executed, the CPU may be halted during the operation. Refer to the Product Specification for more information.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>Address to write to. Must be word-aligned. </td></tr>
    <tr><td class="paramname">src</td><td>Pointer to data to copy from. Must be word-aligned. </td></tr>
    <tr><td class="paramname">num_words</td><td>Number of words to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadefedd962852c5c685c1da242858171c" name="gadefedd962852c5c685c1da242858171c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadefedd962852c5c685c1da242858171c">&#9670;&#160;</a></span>nrfx_nvmc_write_done_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NRFX_STATIC_INLINE bool nrfx_nvmc_write_done_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if the last flash write has been completed. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Last write completed successfully. </td></tr>
    <tr><td class="paramname">false</td><td>Last write is still in progress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="https://github.com/NordicSemiconductor/nrfx/issues" target="_blank">nrfx feedback</a> | <a href="https://devzone.nordicsemi.com/" target="_blank">Nordic DevZone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Fri May 10 2024" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
</script>
</div>
</body>
</html>
